//! Centralized Language Plugin Registry Builder
//!
//! This module provides the single source of truth for building the default
//! language plugin registry. All services that need language intelligence
//! plugins should receive the registry via dependency injection rather than
//! constructing it directly.
//!
//! # Architecture
//!
//! The registry builder uses conditional compilation (`cfg` attributes) to
//! register only the language plugins that are enabled via cargo features.
//! This allows for flexible deployment configurations while maintaining a
//! single point of control.
//!
//! # Usage
//!
//! ```rust,ignore
//! use cb_services::build_language_plugin_registry;
//!
//! // In service initialization:
//! let registry = build_language_plugin_registry();
//! let file_service = FileService::new(
//!     project_root,
//!     ast_cache,
//!     lock_manager,
//!     operation_queue,
//!     config,
//!     registry.clone(),
//! );
//! ```

use cb_core::config::AppConfig;
use cb_plugin_api::{LanguageMetadata, PluginRegistry, ProjectLanguage};
use cb_plugins::{rpc_adapter::RpcAdapterPlugin, PluginProcessManager};
use std::sync::Arc;
use tracing::{info, warn};

/// Build the language plugin registry, including both compiled-in plugins
/// and external plugins defined in the configuration.
///
/// Note: External plugins (if configured) are spawned asynchronously in the background.
/// This allows the function to be called from both sync and async contexts.
pub fn build_language_plugin_registry() -> Arc<PluginRegistry> {
    let mut registry = PluginRegistry::new();
    let mut plugin_count = 0;

    // Load app configuration to find external plugins
    let config = AppConfig::load().unwrap_or_default();

    if !config.language_plugins.plugins.is_empty() {
        warn!("External language plugins are configured but will be skipped in sync context. Use async version for external plugin support.");
        // TODO: In a future version, we could spawn these in a background task
        // For now, external plugins require the async version
    }

    // Include the built-in plugins generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/registry_registration.rs"));

    tracing::debug!(
        plugin_count = plugin_count,
        "Built language plugin registry"
    );

    Arc::new(registry)
}

/// Async version that supports external plugins
pub async fn build_language_plugin_registry_async() -> Arc<PluginRegistry> {
    let mut registry = PluginRegistry::new();
    let mut plugin_count = 0;

    // Load app configuration to find external plugins
    let config = AppConfig::load().unwrap_or_default();

    if !config.language_plugins.plugins.is_empty() {
        let manager = Arc::new(PluginProcessManager::new());
        info!("Spawning external language plugins...");

        for plugin_config in &config.language_plugins.plugins {
            if let Err(e) = manager
                .register_plugin(&plugin_config.name, &plugin_config.command)
                .await
            {
                warn!(plugin_name = %plugin_config.name, error = %e, "Failed to spawn external plugin");
                continue;
            }

            if let Some(process) = manager.get_plugin(&plugin_config.name) {
                // This metadata is created from the config file.
                // We leak the strings to get &'static str for LanguageMetadata.
                let name: &'static str = Box::leak(plugin_config.name.clone().into_boxed_str());
                let extensions: &'static [&'static str] = Box::leak(
                    plugin_config.extensions
                        .iter()
                        .map(|s| Box::leak(s.clone().into_boxed_str()) as &'static str)
                        .collect::<Vec<_>>()
                        .into_boxed_slice()
                );
                let manifest_filename: &'static str = Box::leak(plugin_config.manifest_filename.clone().into_boxed_str());

                let metadata = LanguageMetadata {
                    name,
                    extensions,
                    manifest_filename,
                    // Provide sensible defaults for fields not in the config.
                    source_dir: "src",
                    entry_point: "lib.rs",
                    module_separator: "::",
                    language: ProjectLanguage::Unknown,
                };

                let adapter = Arc::new(RpcAdapterPlugin::new(Arc::new(process), metadata));
                registry.register(adapter);
                plugin_count += 1;
                info!(plugin_name = %plugin_config.name, "Registered external plugin");
            }
        }
    }

    // Include the built-in plugins generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/registry_registration.rs"));

    tracing::debug!(
        total_plugin_count = plugin_count,
        "Built language plugin registry"
    );

    Arc::new(registry)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_registry_builder_creates_non_empty_registry() {
        let registry = build_language_plugin_registry();

        // Should have at least one plugin (assuming default features are enabled)
        assert!(!registry.all().is_empty());
    }

    #[cfg(feature = "lang-rust")]
    #[test]
    fn test_registry_builder_includes_rust_plugin() {
        let registry = build_language_plugin_registry();

        // Should be able to find plugin for .rs files
        let plugin = registry.find_by_extension("rs");
        assert!(plugin.is_some());
        assert_eq!(plugin.unwrap().metadata().name, "Rust");
    }

    #[cfg(feature = "lang-go")]
    #[test]
    fn test_registry_builder_includes_go_plugin() {
        let registry = build_language_plugin_registry();

        // Should be able to find plugin for .go files
        let plugin = registry.find_by_extension("go");
        assert!(plugin.is_some());
        assert_eq!(plugin.unwrap().metadata().name, "Go");
    }

    #[cfg(feature = "lang-typescript")]
    #[test]
    fn test_registry_builder_includes_typescript_plugin() {
        let registry = build_language_plugin_registry();

        // Should be able to find plugin for .ts files
        let plugin = registry.find_by_extension("ts");
        assert!(plugin.is_some());
        assert_eq!(plugin.unwrap().metadata().name, "TypeScript");
    }

    #[cfg(feature = "lang-python")]
    #[test]
    fn test_registry_builder_includes_python_plugin() {
        let registry = build_language_plugin_registry();

        // Should be able to find plugin for .py files
        let plugin = registry.find_by_extension("py");
        assert!(plugin.is_some());
        assert_eq!(plugin.unwrap().metadata().name, "Python");
    }

    #[test]
    fn test_registry_builder_returns_arc() {
        let registry = build_language_plugin_registry();

        // Can clone the Arc for sharing across services
        let registry2 = registry.clone();
        assert_eq!(registry.all().len(), registry2.all().len());
    }
}
