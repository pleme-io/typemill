//! C# Language Plugin for TypeMill
//!
//! Provides AST parsing, symbol extraction, and manifest analysis for C#.

pub mod import_support;
pub mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;

use async_trait::async_trait;
use mill_foundation::protocol::EditPlan;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics, CodeRange,
};
use mill_plugin_api::{
    LanguagePlugin, ManifestData, ParsedSource, PluginResult,
    RefactoringProvider,
};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: CsharpPlugin,
    name: "csharp",
    extensions: ["cs"],
    manifest: ".csproj",
    lsp_command: "csharp-ls",
    lsp_args: [""],
    source_dir: ".",
    entry_point: "Program.cs",
    module_separator: ".",
    capabilities: [with_imports, with_project_factory],
    fields: {
        import_support: import_support::CsharpImportSupport,
        project_factory: project_factory::CsharpProjectFactory,
    },
    doc: "C# language plugin implementation providing comprehensive C# language support"
}

#[async_trait]
impl LanguagePlugin for CsharpPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        }
    }
}

#[async_trait]
impl RefactoringProvider for CsharpPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        // The original implementation used a CodeRange. We will create one here
        // to pass to the existing logic, assuming column 0 to end-of-line.
        let range = CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col: source
                .lines()
                .nth(end_line as usize)
                .map_or(0, |l| l.len() as u32),
        };
        self::refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{CreatePackageConfig, PackageType, Template};
    use std::path::PathBuf;
    use tempfile::tempdir;

    #[tokio::test]
    async fn test_csharp_plugin_basic() {
        let plugin = CsharpPlugin::new();
        assert_eq!(plugin.metadata().name, "csharp");
        assert_eq!(plugin.metadata().extensions, &["cs"]);
        assert!(plugin.handles_extension("cs"));
        assert!(!plugin.handles_extension("rs"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_handles_manifests() {
        let plugin = CsharpPlugin::new();
        assert!(plugin.handles_manifest(".csproj"));
        assert!(!plugin.handles_manifest("Cargo.toml"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_capabilities() {
        let plugin = CsharpPlugin::new();
        let caps = plugin.capabilities();
        assert!(caps.imports);
        assert!(caps.project_factory);
        assert!(plugin.refactoring_provider().is_some());
    }

    #[tokio::test]
    async fn test_create_package() {
        let plugin = CsharpPlugin::new();
        let factory = plugin.project_factory().unwrap();
        let temp_dir = tempdir().unwrap();
        let config = CreatePackageConfig {
            workspace_root: temp_dir.path().to_str().unwrap().to_string(),
            package_path: "MyTestCsharpApp".to_string(),
            package_type: PackageType::Library,
            template: Template::default(),
            add_to_workspace: false,
        };

        let result = factory.create_package(&config);

        // This test requires `dotnet` to be installed on the system.
        if std::process::Command::new("dotnet").output().is_err() {
            println!("Skipping `test_create_package` because `dotnet` is not installed.");
            return;
        }

        assert!(result.is_ok(), "create_package failed: {:?}", result.err());
        let pkg = result.unwrap();
        assert!(!pkg.created_files.is_empty());
        let manifest_path = pkg.package_info.manifest_path;
        assert!(Path::new(&manifest_path).exists());
        assert_eq!(
            Path::new(&manifest_path).file_name().unwrap().to_str().unwrap(),
            "MyTestCsharpApp.csproj"
        );
    }
}