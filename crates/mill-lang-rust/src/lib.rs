//! Rust Language Plugin for TypeMill
//!
//! This crate provides complete Rust language support, implementing both:
//! - `LanguagePlugin` - AST parsing and symbol extraction
//! - Import and workspace support traits

mod manifest;
pub mod parser;
pub mod refactoring;
pub mod workspace;

// Capability trait implementations
pub mod import_support;
pub mod lsp_installer;
pub mod project_factory;
pub mod workspace_support;

// Import-related utilities
pub mod imports;

// String literal path rewriting
mod string_literal_support;

// Consolidation support (Rust-specific post-processing)
pub mod cargo_helpers;
pub mod consolidation;
pub mod dependency_analysis;

// Reference detection for rename/move operations
pub mod reference_detector;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
    manifest_templates::{ManifestTemplate, TomlManifestTemplate},
    read_manifest,
};
use mill_plugin_api::{LanguagePlugin, ManifestData, ParsedSource, PluginResult};
use std::path::Path;

// Import helpers from the imports module
use imports::{compute_module_path_from_file, find_crate_name_from_cargo_toml};

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: RustPlugin,
    name: "rust",
    extensions: ["rs"],
    manifest: "Cargo.toml",
    lsp_command: "rust-analyzer",
    lsp_args: ["rust-analyzer"],
    source_dir: "src",
    entry_point: "lib.rs",
    module_separator: "::",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::RustImportSupport,
        workspace_support: workspace_support::RustWorkspaceSupport,
        reference_detector: reference_detector::RustReferenceDetector,
        project_factory: project_factory::RustProjectFactory,
        lsp_installer: lsp_installer::RustLspInstaller,
    },
    doc: "Rust language plugin implementation"
}

#[async_trait]
impl LanguagePlugin for RustPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        // Extract all symbols from the source code
        let symbols = parser::extract_symbols(source)?;

        // Parse the source into a syn AST and serialize it as JSON
        let ast: syn::File = syn::parse_file(source).map_err(|e| {
            mill_plugin_api::PluginError::parse(format!("Failed to parse Rust code: {}", e))
        })?;

        // Serialize the AST to JSON using quote
        // For now, we'll store a simplified representation
        let ast_json = serde_json::json!({
            "type": "File",
            "items_count": ast.items.len(),
            "shebang": ast.shebang,
        });

        Ok(ParsedSource {
            data: ast_json,
            symbols,
        })
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        // Verify this is a Cargo.toml file
        if path.file_name().and_then(|s| s.to_str()) != Some("Cargo.toml") {
            return Err(mill_plugin_api::PluginError::invalid_input(format!(
                "Expected Cargo.toml, got: {:?}",
                path.file_name()
            )));
        }

        manifest::load_cargo_toml(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    fn analyze_detailed_imports(
        &self,
        source: &str,
        file_path: Option<&Path>,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        parser::analyze_imports(source, file_path)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            module_reference_scanner: ModuleReferenceScanner,
            refactoring_provider: RefactoringProvider,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
            module_declaration_support: ModuleDeclarationSupport,
            module_locator: ModuleLocator,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        reference_detector => {
            reference_detector: ReferenceDetector,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        },
    }

    fn rewrite_file_references(
        &self,
        content: &str,
        old_path: &Path,
        new_path: &Path,
        current_file: &Path,
        project_root: &Path,
        rename_info: Option<&serde_json::Value>,
    ) -> Option<(String, usize)> {
        tracing::info!(
            old_path = %old_path.display(),
            new_path = %new_path.display(),
            current_file = %current_file.display(),
            "RustPlugin::rewrite_file_references ENTRY"
        );

        let result = self.rewrite_imports_for_rename(
            content,
            old_path,
            new_path,
            current_file,
            project_root,
            rename_info,
        );

        let final_result = match result {
            Ok((mut modified_content, mut total_changes)) => {
                tracing::info!(
                    content_len = modified_content.len(),
                    changes_count = total_changes,
                    "RustPlugin::rewrite_file_references import rewrite OK"
                );

                // Also update string literals containing paths
                if let Ok((modified_with_strings, string_changes)) =
                    string_literal_support::rewrite_string_literals(
                        &modified_content,
                        old_path,
                        new_path,
                    )
                {
                    if string_changes > 0 {
                        tracing::debug!(
                            changes = string_changes,
                            "Updated string literals in Rust file"
                        );
                        modified_content = modified_with_strings;
                        total_changes += string_changes;
                    }
                }

                // Phase 3: Comment updates (opt-in via update_comments flag)
                let update_comments = rename_info
                    .and_then(|v| v.get("update_comments"))
                    .and_then(|v| v.as_bool())
                    .unwrap_or(false);

                if update_comments {
                    let old_basename = old_path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or_else(|| old_path.to_str().unwrap_or(""));
                    let new_basename = new_path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or_else(|| new_path.to_str().unwrap_or(""));

                    // Smart boundary matching: NOT preceded/followed by alphanumeric
                    // Allows: "mill-lsp", "mill-lsp-style", "// mill-lsp"
                    // Blocks: "mymill-lsp", "mill-lspsystem"
                    let pattern = format!(
                        r"(?<![a-zA-Z0-9]){}(?![a-zA-Z0-9])",
                        fancy_regex::escape(old_basename)
                    );

                    if let Ok(regex) = fancy_regex::Regex::new(&pattern) {
                        let comment_result = regex.replace_all(&modified_content, new_basename);
                        let comment_count = comment_result.matches(new_basename).count()
                            - modified_content.matches(new_basename).count();

                        if comment_count > 0 {
                            tracing::debug!(
                                comment_changes = comment_count,
                                old_basename = old_basename,
                                new_basename = new_basename,
                                "Updated identifiers in Rust comments"
                            );
                            modified_content = comment_result.to_string();
                            total_changes += comment_count;
                        }
                    }
                }

                Ok((modified_content, total_changes))
            }
            Err(e) => {
                tracing::error!(
                    error = ?e,
                    "RustPlugin::rewrite_file_references ERR"
                );
                Err(e)
            }
        };

        final_result.ok()
    }
}

// ============================================================================
// Capability Trait Implementations
// ============================================================================

impl mill_plugin_api::ModuleReferenceScanner for RustPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> mill_plugin_api::PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        self.find_module_references(content, module_name, scope)
    }
}

#[async_trait]
impl mill_plugin_api::RefactoringProvider for RustPlugin {
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path).map_err(
            |e| mill_plugin_api::PluginError::internal(format!("Rust refactoring error: {}", e)),
        )
    }

    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_function(source, start_line, end_line, function_name, file_path)
            .map_err(|e| {
                mill_plugin_api::PluginError::internal(format!("Rust refactoring error: {}", e))
            })
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| {
            mill_plugin_api::PluginError::internal(format!("Rust refactoring error: {}", e))
        })
    }
}

impl mill_plugin_api::ImportAnalyzer for RustPlugin {
    fn build_import_graph(
        &self,
        file_path: &Path,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::ImportGraph> {
        // Read the file content
        let content = std::fs::read_to_string(file_path).map_err(|e| {
            mill_plugin_api::PluginError::internal(format!("Failed to read file: {}", e))
        })?;

        // Use the existing analyze_detailed_imports method
        self.analyze_detailed_imports(&content, Some(file_path))
    }

    // Note: Unused import detection delegated to analyze.dead_code tool (uses LSP)
}

// ============================================================================
// Manifest Updater Capability
// ============================================================================

#[async_trait::async_trait]
impl mill_plugin_api::ManifestUpdater for RustPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> mill_plugin_api::PluginResult<String> {
        // Delegate to the inherent method implementation
        RustPlugin::update_dependency(self, manifest_path, old_name, new_name, new_version).await
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        // Delegate to the inherent method implementation
        RustPlugin::generate_manifest(self, package_name, dependencies)
    }

    async fn add_path_dependency(
        &self,
        manifest_content: &str,
        dep_name: &str,
        dep_path: &str,
        base_path: &Path,
    ) -> mill_plugin_api::PluginResult<String> {
        // Delegate to the inherent method implementation
        RustPlugin::add_manifest_path_dependency(
            self,
            manifest_content,
            dep_name,
            dep_path,
            base_path,
        )
        .await
    }
}

// ============================================================================
// Module Locator Capability
// ============================================================================

#[async_trait::async_trait]
impl mill_plugin_api::ModuleLocator for RustPlugin {
    async fn locate_module_files(
        &self,
        package_path: &Path,
        module_path: &str,
    ) -> mill_plugin_api::PluginResult<Vec<std::path::PathBuf>> {
        // Delegate to the inherent method implementation
        RustPlugin::locate_module_files(self, package_path, module_path).await
    }
}

// ============================================================================
// Module Declaration Support Capability
// ============================================================================

#[async_trait::async_trait]
impl mill_plugin_api::ModuleDeclarationSupport for RustPlugin {
    async fn remove_module_declaration(
        &self,
        source: &str,
        module_name: &str,
    ) -> mill_plugin_api::PluginResult<String> {
        // Delegate to the inherent method implementation
        RustPlugin::remove_module_declaration(self, source, module_name).await
    }
}

// ============================================================================
// Plugin-specific helper methods for consumers
// These are NOT part of capability traits - they're Rust-specific utilities
// ============================================================================

impl RustPlugin {
    /// Update a dependency in Cargo.toml manifest
    pub async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = read_manifest(manifest_path).await?;

        // For Rust, new_version might be a path or a version
        // If it looks like a path, use path dependency; otherwise use version
        if let Some(version_or_path) = new_version {
            if version_or_path.contains('/') || version_or_path.contains('\\') {
                // It's a path dependency - use rename with path
                manifest::rename_dependency(&content, old_name, new_name, Some(version_or_path))
            } else {
                // It's a version - use rename with version as path (Cargo.toml uses same field)
                manifest::rename_dependency(&content, old_name, new_name, Some(version_or_path))
            }
        } else {
            // No version provided, just update the name
            manifest::rename_dependency(&content, old_name, new_name, None)
        }
    }

    /// Locate module files for a given module path
    ///
    /// Navigates the Rust module system to find .rs files for a module path like "services::planner"
    pub async fn locate_module_files(
        &self,
        package_path: &Path,
        module_path: &str,
    ) -> PluginResult<Vec<std::path::PathBuf>> {
        // Handle empty module path
        if module_path.is_empty() {
            return Err(mill_plugin_api::PluginError::invalid_input(
                "Module path cannot be empty",
            ));
        }

        // Normalize module path (handle both:: and . separators)
        let normalized = module_path.replace('.', "::");
        let parts: Vec<&str> = normalized.split("::").collect();

        // Start from src/ directory
        let src_dir = package_path.join("src");
        if !src_dir.exists() {
            return Err(mill_plugin_api::PluginError::internal(format!(
                "Source directory not found: {}",
                src_dir.display()
            )));
        }

        let mut current_path = src_dir;
        let mut result_files = Vec::new();

        // Navigate through module path components
        for (i, part) in parts.iter().enumerate() {
            let is_last = i == parts.len() - 1;

            if is_last {
                // Check for module.rs or module/mod.rs
                let single_file = current_path.join(format!("{}.rs", part));
                let mod_dir = current_path.join(part).join("mod.rs");

                if single_file.exists() {
                    result_files.push(single_file);
                } else if mod_dir.exists() {
                    result_files.push(mod_dir);
                } else {
                    return Err(mill_plugin_api::PluginError::invalid_input(format!(
                        "Module not found: {}",
                        module_path
                    )));
                }
            } else {
                // Navigate to subdirectory
                current_path = current_path.join(part);
                if !current_path.exists() {
                    return Err(mill_plugin_api::PluginError::invalid_input(format!(
                        "Module path not found: {}",
                        current_path.display()
                    )));
                }
            }
        }

        Ok(result_files)
    }

    /// Parse imports from a file path (async wrapper)
    pub async fn parse_imports(&self, file_path: &Path) -> PluginResult<Vec<String>> {
        let content = read_manifest(file_path).await?;

        // Use the parser module to extract imports
        let import_infos = parser::parse_imports(&content)?;

        // Extract just the module paths
        Ok(import_infos.iter().map(|i| i.module_path.clone()).collect())
    }

    /// Generate a Cargo.toml manifest
    pub fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        let template = TomlManifestTemplate::new("package");
        let mut manifest = template.generate(package_name, "0.1.0", dependencies);

        // Add Rust-specific edition field
        if let Some(version_pos) = manifest.find("version = \"0.1.0\"") {
            let insert_pos = manifest[version_pos..]
                .find('\n')
                .map(|p| version_pos + p + 1);
            if let Some(pos) = insert_pos {
                manifest.insert_str(pos, "edition = \"2021\"\n");
            }
        }

        manifest
    }

    /// Remove module declaration from source
    pub async fn remove_module_declaration(
        &self,
        source: &str,
        module_name: &str,
    ) -> PluginResult<String> {
        use syn::{File, Item};

        // Parse the source file
        let ast: File = syn::parse_file(source).map_err(|e| {
            mill_plugin_api::PluginError::parse(format!("Failed to parse Rust code: {}", e))
        })?;

        // Filter out module declarations matching the name
        let filtered_items: Vec<Item> = ast
            .items
            .into_iter()
            .filter(|item| {
                if let Item::Mod(item_mod) = item {
                    item_mod.ident != module_name
                } else {
                    true
                }
            })
            .collect();

        // Reconstruct the file
        let new_ast = File {
            shebang: ast.shebang,
            attrs: ast.attrs,
            items: filtered_items,
        };

        // Convert back to source code
        Ok(quote::quote!(#new_ast).to_string())
    }

    /// Update module declaration name in source (e.g., `pub mod old;` -> `pub mod new;`)
    ///
    /// Uses line-by-line replacement with regex to preserve formatting.
    pub fn update_module_declaration(
        &self,
        source: &str,
        old_module_name: &str,
        new_module_name: &str,
    ) -> PluginResult<(String, usize)> {
        let mut updated_lines = Vec::new();
        let mut changes = 0;

        for line in source.lines() {
            let trimmed = line.trim();

            // Check if this line is a mod declaration for the old module
            let is_mod_decl = (trimmed.starts_with("pub mod ")
                || trimmed.starts_with("mod ")
                || trimmed.starts_with("pub(crate) mod ")
                || trimmed.starts_with("pub(super) mod "))
                && (trimmed.contains(&format!("{};", old_module_name))
                    || trimmed.contains(&format!("{} ", old_module_name)));

            if is_mod_decl {
                // Use word boundary replacement to avoid partial matches
                // This handles both "mod helpers;" and "mod helpers {" cases
                let updated_line = line
                    .replace(
                        &format!(" {};", old_module_name),
                        &format!(" {};", new_module_name),
                    )
                    .replace(
                        &format!(" {} ", old_module_name),
                        &format!(" {} ", new_module_name),
                    );

                if updated_line != line {
                    updated_lines.push(updated_line);
                    changes += 1;
                } else {
                    updated_lines.push(line.to_string());
                }
            } else {
                updated_lines.push(line.to_string());
            }
        }

        // Preserve the original line ending style
        let has_trailing_newline = source.ends_with('\n');
        let mut result = updated_lines.join("\n");
        if has_trailing_newline {
            result.push('\n');
        }

        Ok((result, changes))
    }

    /// Update qualified paths in source (e.g., `utils::helper()` -> `helpers::helper()`)
    ///
    /// Updates inline qualified paths that reference a renamed module.
    /// Also handles nested paths like `parent::old_module::` -> `parent::new_module::`
    pub fn update_qualified_paths(
        &self,
        source: &str,
        old_module_name: &str,
        new_module_name: &str,
    ) -> PluginResult<(String, usize)> {
        let mut updated_content = source.to_string();
        let mut changes = 0;

        // Pattern 1: Direct qualified paths - "old_module::"
        let old_pattern = format!("{}::", old_module_name);
        let new_pattern = format!("{}::", new_module_name);

        let count = updated_content.matches(&old_pattern).count();
        if count > 0 {
            updated_content = updated_content.replace(&old_pattern, &new_pattern);
            changes += count;
        }

        // Pattern 2: Nested paths - "::old_module::" (after parent module)
        let old_nested_pattern = format!("::{}::", old_module_name);
        let new_nested_pattern = format!("::{}::", new_module_name);

        let nested_count = updated_content.matches(&old_nested_pattern).count();
        if nested_count > 0 {
            updated_content = updated_content.replace(&old_nested_pattern, &new_nested_pattern);
            changes += nested_count;
        }

        Ok((updated_content, changes))
    }

    /// Add path dependency to manifest
    pub async fn add_manifest_path_dependency(
        &self,
        manifest_content: &str,
        dep_name: &str,
        dep_path: &str,
        source_path: &Path,
    ) -> PluginResult<String> {
        workspace::add_path_dependency(manifest_content, dep_name, dep_path, source_path)
    }

    /// Generate workspace manifest
    pub async fn generate_workspace_manifest(
        &self,
        member_paths: &[&str],
        workspace_root: &Path,
    ) -> PluginResult<String> {
        workspace::generate_workspace_manifest(member_paths, workspace_root)
    }

    /// Find source files in directory
    pub async fn find_source_files(&self, dir: &Path) -> PluginResult<Vec<std::path::PathBuf>> {
        use tokio::fs;

        let mut result = Vec::new();
        let mut queue = vec![dir.to_path_buf()];

        while let Some(current_dir) = queue.pop() {
            let mut entries = fs::read_dir(&current_dir).await.map_err(|e| {
                mill_plugin_api::PluginError::internal(format!(
                    "Failed to read directory {}: {}",
                    current_dir.display(),
                    e
                ))
            })?;

            while let Some(entry) = entries.next_entry().await.map_err(|e| {
                mill_plugin_api::PluginError::internal(format!("Failed to read entry: {}", e))
            })? {
                let path = entry.path();
                let metadata = entry.metadata().await.map_err(|e| {
                    mill_plugin_api::PluginError::internal(format!("Failed to get metadata: {}", e))
                })?;

                if metadata.is_dir() {
                    queue.push(path);
                } else if path.extension().and_then(|s| s.to_str()) == Some("rs") {
                    result.push(path);
                }
            }
        }

        Ok(result)
    }

    /// Rewrite import statement
    pub fn rewrite_import(&self, old_import: &str, new_package_name: &str) -> String {
        // Transform "crate::module" or "crate" to "new_package::module"
        if old_import == "crate" {
            format!("use {};", new_package_name)
        } else if let Some(rest) = old_import.strip_prefix("crate::") {
            format!("use {}::{};", new_package_name, rest)
        } else {
            // If it doesn't start with crate::, return as-is
            format!("use {};", old_import)
        }
    }

    /// Find module references with full signature
    pub fn find_module_references(
        &self,
        content: &str,
        module_to_find: &str,
        _scope: mill_plugin_api::ScanScope,
    ) -> PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        use mill_plugin_api::{ModuleReference, ReferenceKind};
        use syn::{File, Item};

        let ast: File = syn::parse_file(content).map_err(|e| {
            mill_plugin_api::PluginError::parse(format!("Failed to parse Rust code: {}", e))
        })?;

        let mut references = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        for (line_num, item) in ast.items.iter().enumerate() {
            if let Item::Use(item_use) = item {
                let use_str = quote::quote!(#item_use).to_string();
                if use_str.contains(module_to_find) {
                    // Get the actual line length from source content, not from quote-generated string
                    // The quote-generated string may have different formatting/whitespace
                    let actual_line = if line_num < lines.len() {
                        lines[line_num]
                    } else {
                        ""
                    };

                    // We need to replace the entire use statement line, not just the module name
                    // The text field contains the full formatted import from quote::quote!
                    // So column should be 0 and length should be the entire line length
                    let column = 0;
                    let length = actual_line.len();

                    references.push(ModuleReference {
                        line: line_num + 1, // 1-based
                        column,
                        length,
                        text: use_str,
                        kind: ReferenceKind::Declaration,
                    });
                }
            }
        }

        Ok(references)
    }

    /// Rewrite imports for rename with full signature
    pub fn rewrite_imports_for_rename(
        &self,
        content: &str,
        _old_path: &Path,
        _new_path: &Path,
        _importing_file: &Path,
        _project_root: &Path,
        rename_info: Option<&serde_json::Value>,
    ) -> PluginResult<(String, usize)> {
        tracing::info!(
            old_path = %_old_path.display(),
            new_path = %_new_path.display(),
            importing_file = %_importing_file.display(),
            "RustPlugin::rewrite_imports_for_rename ENTRY"
        );

        let mut updated_content = content.to_string();
        let mut total_changes = 0;

        // Step 1: Detect if this is a directory rename or file rename
        // For directory renames, we need to use the directory name as the module name
        let is_directory_rename = _old_path.is_dir() && _new_path.parent().is_some();

        // Step 2: Check if this is a parent file that might contain mod declarations
        // For file renames: Parent files are lib.rs or mod.rs in the same directory
        // For directory renames: Parent files are lib.rs, mod.rs, or main.rs in the parent directory
        let is_parent_file = if is_directory_rename {
            let old_parent = _old_path.parent();
            let importing_filename = _importing_file.file_name().and_then(|n| n.to_str());

            old_parent.is_some()
                && _importing_file.parent() == old_parent
                && (importing_filename == Some("lib.rs")
                    || importing_filename == Some("mod.rs")
                    || importing_filename == Some("main.rs"))
        } else {
            let old_parent = _old_path.parent();
            let importing_filename = _importing_file.file_name().and_then(|n| n.to_str());

            old_parent.is_some()
                && _importing_file.parent() == old_parent
                && (importing_filename == Some("lib.rs") || importing_filename == Some("mod.rs"))
        };

        // Extract module names
        // For directory renames: use directory name (e.g., "src/utils" -> "utils")
        // For file renames: use file stem (e.g., "src/utils.rs" -> "utils")
        let (old_module_name, new_module_name) = if is_directory_rename {
            let old_mod = _old_path
                .file_name()
                .and_then(|s| s.to_str())
                .map(String::from);
            let new_mod = _new_path
                .file_name()
                .and_then(|s| s.to_str())
                .map(String::from);
            (old_mod, new_mod)
        } else {
            let old_mod = _old_path
                .file_stem()
                .and_then(|s| s.to_str())
                .map(String::from);
            let new_mod = _new_path
                .file_stem()
                .and_then(|s| s.to_str())
                .map(String::from);
            (old_mod, new_mod)
        };

        if is_parent_file {
            if let (Some(ref old_mod), Some(ref new_mod)) = (&old_module_name, &new_module_name) {
                tracing::info!(
                    old_module = %old_mod,
                    new_module = %new_mod,
                    "Updating mod declaration in parent file"
                );

                // Update mod declarations (pub mod old; -> pub mod new;)
                match self.update_module_declaration(&updated_content, old_mod, new_mod) {
                    Ok((new_content, changes)) => {
                        if changes > 0 {
                            updated_content = new_content;
                            total_changes += changes;
                            tracing::info!(changes = changes, "Updated mod declarations");
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            error = %e,
                            "Failed to update mod declarations, continuing with use statement updates"
                        );
                    }
                }
            }
        }

        // For simple file renames in same directory, also update use statements and qualified paths
        // Example: "use utils::helper;" -> "use helpers::helper;" when renaming utils.rs -> helpers.rs
        // Example: "utils::helper()" -> "helpers::helper()" in code
        if let (Some(ref old_mod), Some(ref new_mod)) = (&old_module_name, &new_module_name) {
            if _old_path.parent() == _new_path.parent() {
                // Simple rename in same directory - update use statements
                let old_use_pattern = format!("use {}::", old_mod);
                let new_use_pattern = format!("use {}::", new_mod);

                if updated_content.contains(&old_use_pattern) {
                    let before = updated_content.clone();
                    updated_content = updated_content.replace(&old_use_pattern, &new_use_pattern);
                    if updated_content != before {
                        let changes = before.matches(&old_use_pattern).count();
                        total_changes += changes;
                        tracing::info!(
                            old_module = %old_mod,
                            new_module = %new_mod,
                            changes = changes,
                            "Updated simple use statements for file rename"
                        );
                    }
                }

                // Also update qualified paths in code (e.g., utils::helper() calls)
                match self.update_qualified_paths(&updated_content, old_mod, new_mod) {
                    Ok((new_content, changes)) => {
                        if changes > 0 {
                            updated_content = new_content;
                            total_changes += changes;
                            tracing::info!(
                                old_module = %old_mod,
                                new_module = %new_mod,
                                changes = changes,
                                "Updated qualified paths for file rename"
                            );
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            error = %e,
                            "Failed to update qualified paths, continuing"
                        );
                    }
                }
            }
        }

        // Step 2: Update use statements (existing logic)
        // Delegate to import capability with simpler signature
        if let Some(rename_support) = self.import_rename_support() {
            if let Some(info) = rename_info {
                let old_name = info["old_crate_name"].as_str().unwrap_or("");
                let new_name = info["new_crate_name"].as_str().unwrap_or("");

                // Convert Cargo.toml names (with hyphens) to Rust identifiers (with underscores)
                // Cargo: "integration-tests" -> Rust: "integration_tests"
                let old_rust_name = old_name.replace('-', "_");
                let new_rust_name = new_name.replace('-', "_");

                tracing::info!(
                    old_cargo_name = %old_name,
                    new_cargo_name = %new_name,
                    old_rust_name = %old_rust_name,
                    new_rust_name = %new_rust_name,
                    "Converting crate names for Rust import rewriting"
                );

                let (new_content, changes) = rename_support.rewrite_imports_for_rename(
                    &updated_content,
                    &old_rust_name,
                    &new_rust_name,
                );
                total_changes += changes;
                updated_content = new_content;
            } else {
                // This is a file move, not a crate rename. Infer crate from path.
                // Strip project_root to get relative path, then extract crate name (first component)

                // Canonicalize project_root to handle symlinks (e.g., /var vs /private/var on macOS)
                let canonical_project = _project_root
                    .canonicalize()
                    .unwrap_or_else(|_| _project_root.to_path_buf());

                // Try to canonicalize paths, fallback to original if they don't exist yet
                let canonical_old = _old_path
                    .canonicalize()
                    .unwrap_or_else(|_| _old_path.to_path_buf());
                let canonical_new = _new_path
                    .canonicalize()
                    .unwrap_or_else(|_| _new_path.to_path_buf());

                // Extract crate name from relative path (first component after project root)
                let old_crate_name = canonical_old
                    .strip_prefix(&canonical_project)
                    .ok()
                    .and_then(|rel| {
                        tracing::debug!(
                            relative_old = %rel.display(),
                            "Stripped old path to get relative"
                        );
                        rel.components().next()
                    })
                    .and_then(|c| c.as_os_str().to_str())
                    .map(String::from);

                let new_crate_name = canonical_new
                    .strip_prefix(&canonical_project)
                    .ok()
                    .and_then(|rel| {
                        tracing::debug!(
                            relative_new = %rel.display(),
                            "Stripped new path to get relative"
                        );
                        rel.components().next()
                    })
                    .and_then(|c| c.as_os_str().to_str())
                    .map(String::from);

                tracing::debug!(
                    old_crate = ?old_crate_name,
                    new_crate = ?new_crate_name,
                    "Extracted crate names from paths"
                );

                // Fallback: If crate name extraction failed, try finding Cargo.toml
                let old_crate_name = old_crate_name.or_else(|| {
                    tracing::info!(
                        old_path = %_old_path.display(),
                        "Path extraction failed for old_path, trying Cargo.toml fallback"
                    );
                    find_crate_name_from_cargo_toml(_old_path)
                });

                let new_crate_name = new_crate_name.or_else(|| {
                    tracing::info!(
                        new_path = %_new_path.display(),
                        "Path extraction failed for new_path, trying Cargo.toml fallback"
                    );
                    find_crate_name_from_cargo_toml(_new_path)
                });

                tracing::info!(
                    old_crate = ?old_crate_name,
                    new_crate = ?new_crate_name,
                    old_path = %_old_path.display(),
                    new_path = %_new_path.display(),
                    project_root = %_project_root.display(),
                    "After fallback crate name extraction"
                );

                if let (Some(ref old_name), Some(ref new_name)) = (&old_crate_name, &new_crate_name)
                {
                    tracing::info!(
                        old_name = %old_name,
                        new_name = %new_name,
                        "Both crate names extracted successfully"
                    );

                    // Always compute full module paths including file structure
                    // This allows us to detect moves within the same crate
                    let old_module_path =
                        compute_module_path_from_file(_old_path, old_name, &canonical_project);
                    let new_module_path =
                        compute_module_path_from_file(_new_path, new_name, &canonical_project);

                    tracing::info!(
                        old_module_path = %old_module_path,
                        new_module_path = %new_module_path,
                        "Computed full module paths for comparison"
                    );

                    // Rewrite if module paths differ (handles both cross-crate and same-crate moves)
                    if old_module_path != new_module_path {
                        let (new_content, changes) = rename_support.rewrite_imports_for_rename(
                            &updated_content,
                            &old_module_path,
                            &new_module_path,
                        );
                        total_changes += changes;
                        updated_content = new_content;
                        tracing::info!(
                            result_len = updated_content.len(),
                            changes_count = changes,
                            total_changes = total_changes,
                            "Rewrite completed"
                        );
                    } else {
                        tracing::info!(
                            "Module paths are identical - no use statement rewrite needed"
                        );
                    }
                } else {
                    tracing::error!(
                        old_crate = ?old_crate_name,
                        new_crate = ?new_crate_name,
                        "Failed to extract crate names - no rewrite possible"
                    );
                }
            }
        }

        tracing::info!(
            total_changes = total_changes,
            "Returning result from rewrite_imports_for_rename"
        );
        Ok((updated_content, total_changes))
    }
}

// Re-export public API items
pub use manifest::{load_cargo_toml, parse_cargo_toml, rename_dependency};
pub use parser::{extract_symbols, list_functions, parse_imports, rewrite_use_tree};
pub use workspace::{
    add_path_dependency, add_workspace_member, generate_workspace_manifest, is_workspace_manifest,
};

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_rust_plugin_basic() {
        let plugin = RustPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();

        assert_eq!(plugin_trait.metadata().name, "rust");
        assert_eq!(plugin_trait.metadata().extensions, &["rs"]);
        assert!(plugin_trait.handles_extension("rs"));
        assert!(!plugin_trait.handles_extension("py"));
    }

    #[tokio::test]
    async fn test_rust_plugin_parse() {
        let plugin = RustPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();
        let source = r#"
/// A test function
fn test_function() {
    println!("Hello, world!");
}

struct TestStruct {
    field: i32,
}
"#;

        let parsed = plugin_trait.parse(source).await.unwrap();

        // Should extract both function and struct
        assert_eq!(parsed.symbols.len(), 2);

        // Check function
        let func = parsed
            .symbols
            .iter()
            .find(|s| s.name == "test_function")
            .unwrap();
        assert_eq!(func.kind, mill_plugin_api::SymbolKind::Function);
        assert!(func.documentation.is_some());

        // Check struct
        let struc = parsed
            .symbols
            .iter()
            .find(|s| s.name == "TestStruct")
            .unwrap();
        assert_eq!(struc.kind, mill_plugin_api::SymbolKind::Struct);
    }

    #[tokio::test]
    async fn test_rust_plugin_list_functions() {
        let plugin = RustPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();
        let source = r#"
fn first() {}
fn second() {}

impl MyStruct {
    fn method() {}
}
"#;

        let functions = plugin_trait.list_functions(source).await.unwrap();
        assert_eq!(functions.len(), 3);
        assert!(functions.contains(&"first".to_string()));
        assert!(functions.contains(&"second".to_string()));
        assert!(functions.contains(&"method".to_string()));
    }

    #[tokio::test]
    async fn test_rust_plugin_parse_error() {
        let plugin = RustPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();
        let invalid_source = "fn incomplete_function {";

        let result = plugin_trait.parse(invalid_source).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_rewrite_imports_preserves_non_use_content() {
        let plugin = RustPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();

        // Source with use statements AND other content that contains the crate name
        let source = r#"use old_crate::Foo;
use old_crate::bar::Baz;

/// Documentation mentioning old_crate
pub struct Wrapper {
    old_crate_field: String,  // Should NOT be changed
}

impl Wrapper {
    fn init_old_crate() {  // Should NOT be changed
        log::info!("Using old_crate");  // Should NOT be changed
    }
}"#;

        // Use the ImportRenameSupport trait method instead
        let rename_support = plugin_trait.import_rename_support().unwrap();
        let (result, count) = mill_plugin_api::ImportRenameSupport::rewrite_imports_for_rename(
            rename_support,
            source,
            "old_crate",
            "new_crate",
        );

        // Should have changed exactly 2 use statements
        assert_eq!(count, 2);

        // Verify use statements were rewritten (note: quote! adds spaces around::)
        assert!(result.contains("use new_crate"));
        assert!(result.contains("Foo"));
        assert!(result.contains("bar"));
        assert!(result.contains("Baz"));

        // Verify other content was NOT changed
        assert!(result.contains("old_crate_field"));
        assert!(result.contains("fn init_old_crate()"));
        assert!(result.contains(r#"log::info!("Using old_crate");"#));
        assert!(result.contains("/// Documentation mentioning old_crate"));

        // Verify old use statements with old_crate are gone
        assert!(!result.contains("use old_crate"));
    }

    #[test]
    fn test_compute_module_path_from_file_simple() {
        let project_root = Path::new("/workspace");

        // Test simple file: common/src/utils.rs → common::utils
        let file_path = Path::new("/workspace/common/src/utils.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common::utils");
    }

    #[test]
    fn test_compute_module_path_from_file_mod_rs() {
        let project_root = Path::new("/workspace");

        // Test mod.rs: common/src/utils/mod.rs → common::utils (NOT common::utils::mod)
        let file_path = Path::new("/workspace/common/src/utils/mod.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common::utils");
    }

    #[test]
    fn test_compute_module_path_from_file_nested_mod_rs() {
        let project_root = Path::new("/workspace");

        // Test nested mod.rs: common/src/foo/bar/mod.rs → common::foo::bar
        let file_path = Path::new("/workspace/common/src/foo/bar/mod.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common::foo::bar");
    }

    #[test]
    fn test_compute_module_path_from_file_lib_rs() {
        let project_root = Path::new("/workspace");

        // Test lib.rs (crate root): common/src/lib.rs → common
        let file_path = Path::new("/workspace/common/src/lib.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common");
    }

    #[test]
    fn test_compute_module_path_from_file_main_rs() {
        let project_root = Path::new("/workspace");

        // Test main.rs (crate root): common/src/main.rs → common
        let file_path = Path::new("/workspace/common/src/main.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common");
    }

    #[test]
    fn test_compute_module_path_from_file_nested() {
        let project_root = Path::new("/workspace");

        // Test nested file: common/src/foo/bar.rs → common::foo::bar
        let file_path = Path::new("/workspace/common/src/foo/bar.rs");
        let result = compute_module_path_from_file(file_path, "common", project_root);
        assert_eq!(result, "common::foo::bar");
    }

    #[tokio::test]
    async fn test_rewrite_imports_same_crate_file_move() {
        let plugin = RustPlugin::default();
        let project_root = Path::new("/workspace");

        // Source file with import from common::utils
        let source = r#"use common::utils::calculate;

pub fn process(x: i32) -> i32 {
    calculate(x)
}"#;

        // Simulate moving common/src/utils.rs → common/src/helpers.rs
        let old_path = Path::new("/workspace/common/src/utils.rs");
        let new_path = Path::new("/workspace/common/src/helpers.rs");
        let current_file = Path::new("/workspace/common/src/processor.rs");

        let result = plugin
            .rewrite_imports_for_rename(
                source,
                old_path,
                new_path,
                current_file,
                project_root,
                None,
            )
            .unwrap();

        let (new_content, count) = result;

        // Should have changed 1 import
        assert_eq!(count, 1, "Expected 1 import to be updated");

        // Verify import was rewritten from common::utils to common::helpers
        assert!(
            new_content.contains("use common::helpers::calculate"),
            "Import should be updated to common::helpers::calculate"
        );
        assert!(
            !new_content.contains("use common::utils"),
            "Old import with common::utils should be gone"
        );

        // Verify function body unchanged
        assert!(new_content.contains("calculate(x)"));
    }

    #[test]
    fn test_update_module_declaration() {
        let plugin = RustPlugin::default();

        let source = "pub mod utils;\n\npub fn lib_fn() {\n    utils::helper();\n}\n";

        let result = plugin
            .update_module_declaration(source, "utils", "helpers")
            .unwrap();

        assert_eq!(result.1, 1, "Should have 1 change");
        assert!(
            result.0.contains("pub mod helpers;"),
            "Should contain 'pub mod helpers;'\nActual: {}",
            result.0
        );
        assert!(
            !result.0.contains("pub mod utils;"),
            "Should not contain 'pub mod utils;'\nActual: {}",
            result.0
        );
    }

    #[test]
    fn test_update_qualified_paths() {
        let plugin = RustPlugin::default();

        let source = "pub fn lib_fn() {\n    utils::helper();\n    utils::another();\n}\n";

        let result = plugin
            .update_qualified_paths(source, "utils", "helpers")
            .unwrap();

        assert_eq!(result.1, 2, "Should have 2 changes");
        assert!(
            result.0.contains("helpers::helper()"),
            "Should contain 'helpers::helper()'\nActual: {}",
            result.0
        );
        assert!(
            result.0.contains("helpers::another()"),
            "Should contain 'helpers::another()'\nActual: {}",
            result.0
        );
        assert!(
            !result.0.contains("utils::"),
            "Should not contain 'utils::'\nActual: {}",
            result.0
        );
    }

    #[test]
    fn test_rewrite_imports_for_rename_updates_mod_declaration() {
        let plugin = RustPlugin::default();
        let project_root = Path::new("/tmp/test_project");

        // Source: lib.rs with mod declaration
        let lib_source = "pub mod utils;\n\npub fn lib_fn() {\n    utils::helper();\n}\n";

        // Simulate renaming src/utils.rs → src/helpers.rs
        // lib.rs is at src/lib.rs (parent of utils.rs)
        let old_path = Path::new("/tmp/test_project/src/utils.rs");
        let new_path = Path::new("/tmp/test_project/src/helpers.rs");
        let lib_rs = Path::new("/tmp/test_project/src/lib.rs");

        let result = plugin
            .rewrite_imports_for_rename(lib_source, old_path, new_path, lib_rs, project_root, None)
            .unwrap();

        let (new_content, count) = result;

        // Should have updated the mod declaration
        assert!(count > 0, "Should have at least 1 change");
        assert!(
            new_content.contains("pub mod helpers;"),
            "Should contain 'pub mod helpers;'\nActual: {}",
            new_content
        );
        assert!(
            !new_content.contains("pub mod utils;"),
            "Should not contain 'pub mod utils;'\nActual: {}",
            new_content
        );
    }

    #[test]
    fn test_updates_comments_with_flag() {
        let content = r#"
//! System components (now moved to old-lsp crate)

// Re-export from old-lsp for backward compatibility
pub use old_lsp::LspClient;

// Don't use myold-lsp (should NOT change)
"#;

        let plugin = RustPlugin::new();

        let rename_info = serde_json::json!({
            "update_comments": true
        });

        let result = plugin.rewrite_file_references(
            content,
            Path::new("crates/old-lsp"),
            Path::new("crates/new-lsp"),
            Path::new("src/main.rs"),
            Path::new("/workspace"),
            Some(&rename_info),
        );

        assert!(result.is_some());
        let (new_content, count) = result.unwrap();

        // Should update 2 comments
        assert!(count >= 2, "Should have at least 2 changes, got {}", count);
        assert!(
            new_content.contains("new-lsp crate"),
            "Should update first comment"
        );
        assert!(
            new_content.contains("from new-lsp"),
            "Should update second comment"
        );

        // Should NOT update partial match
        assert!(
            new_content.contains("myold-lsp"),
            "Should preserve partial matches"
        );
    }

    #[test]
    fn test_comments_not_updated_without_flag() {
        let content = r#"
//! System components (now moved to old-lsp crate)

// Re-export from old-lsp for backward compatibility
pub use old_lsp::LspClient;
"#;

        let plugin = RustPlugin::new();

        // No update_comments flag
        let rename_info = serde_json::json!({});

        let result = plugin.rewrite_file_references(
            content,
            Path::new("crates/old-lsp"),
            Path::new("crates/new-lsp"),
            Path::new("src/main.rs"),
            Path::new("/workspace"),
            Some(&rename_info),
        );

        assert!(result.is_some());
        let (new_content, _count) = result.unwrap();

        // Comments should NOT be updated without flag
        assert!(
            new_content.contains("old-lsp crate"),
            "Should preserve first comment without flag"
        );
        assert!(
            new_content.contains("from old-lsp"),
            "Should preserve second comment without flag"
        );
    }
}
