//! Language Plugin Bundle
//!
//! This file is AUTO-GENERATED by `cargo xtask sync-languages`.
//! Do not edit manually - changes will be overwritten.
//!
//! To add a new language:
//! 1. Add entry to languages.toml
//! 2. Run: cargo xtask sync-languages

use mill_plugin_api::{iter_plugins, LanguagePlugin};
use std::sync::Arc;

// Force linker to include language plugins by actively using them.
// This prevents linker dead code elimination from stripping the inventory submissions.
// We reference each plugin's public type to ensure the crate is linked.
#[cfg(feature = "lang-gitignore")]
use mill_lang_gitignore::GitignoreLanguagePlugin;
#[cfg(feature = "lang-lua")]
use mill_lang_lua::LuaPlugin;
#[cfg(feature = "lang-markdown")]
use mill_lang_markdown::MarkdownPlugin;
#[cfg(feature = "lang-python")]
use mill_lang_python::PythonPlugin;
#[cfg(feature = "lang-rust")]
use mill_lang_rust::RustPlugin;
#[cfg(feature = "lang-shell")]
use mill_lang_shell::ShellPlugin;
#[cfg(feature = "lang-svelte")]
use mill_lang_svelte::SveltePlugin;
#[cfg(feature = "lang-toml")]
use mill_lang_toml::TomlLanguagePlugin;
#[cfg(feature = "lang-typescript")]
use mill_lang_typescript::TypeScriptPlugin;
#[cfg(feature = "lang-yaml")]
use mill_lang_yaml::YamlLanguagePlugin;
#[cfg(feature = "lang-zig")]
use mill_lang_zig::ZigPlugin;

// This function is never called but ensures the linker includes all plugin crates
#[allow(dead_code)]
fn _force_plugin_linkage() {
    // These type references ensure the plugin crates are linked
    // The actual plugin instances will be discovered via inventory
    #[cfg(feature = "lang-gitignore")]
    let _: Option<GitignoreLanguagePlugin> = None;
    #[cfg(feature = "lang-lua")]
    let _: Option<LuaPlugin> = None;
    #[cfg(feature = "lang-markdown")]
    let _: Option<MarkdownPlugin> = None;
    #[cfg(feature = "lang-python")]
    let _: Option<PythonPlugin> = None;
    #[cfg(feature = "lang-rust")]
    let _: Option<RustPlugin> = None;
    #[cfg(feature = "lang-shell")]
    let _: Option<ShellPlugin> = None;
    #[cfg(feature = "lang-svelte")]
    let _: Option<SveltePlugin> = None;
    #[cfg(feature = "lang-toml")]
    let _: Option<TomlLanguagePlugin> = None;
    #[cfg(feature = "lang-typescript")]
    let _: Option<TypeScriptPlugin> = None;
    #[cfg(feature = "lang-yaml")]
    let _: Option<YamlLanguagePlugin> = None;
    #[cfg(feature = "lang-zig")]
    let _: Option<ZigPlugin> = None;
}

/// Returns all language plugins available in this bundle.
///
/// This function uses the plugin registry's auto-discovery mechanism
/// to find all plugins that have self-registered using the `mill_plugin!` macro.
pub fn all_plugins() -> Vec<Arc<dyn LanguagePlugin>> {
    let plugins: Vec<_> = iter_plugins()
        .map(|descriptor| {
            tracing::debug!(
                plugin_name = descriptor.name,
                extensions = ?descriptor.extensions,
                "Discovered language plugin via inventory"
            );
            let plugin = (descriptor.factory)();
            Arc::from(plugin) as Arc<dyn LanguagePlugin>
        })
        .collect();

    tracing::info!(
        plugin_count = plugins.len(),
        "Language plugin bundle discovery complete"
    );

    if plugins.is_empty() {
        tracing::warn!("No language plugins discovered - inventory system may be broken");
    }

    plugins
}

#[cfg(test)]
mod tests {
    use super::*;

    // Force linker to include language plugins for inventory collection in tests
    #[cfg(all(test, feature = "lang-gitignore"))]
    extern crate mill_lang_gitignore;
    #[cfg(all(test, feature = "lang-lua"))]
    extern crate mill_lang_lua;
    #[cfg(all(test, feature = "lang-markdown"))]
    extern crate mill_lang_markdown;
    #[cfg(all(test, feature = "lang-python"))]
    extern crate mill_lang_python;
    #[cfg(all(test, feature = "lang-rust"))]
    extern crate mill_lang_rust;
    #[cfg(all(test, feature = "lang-shell"))]
    extern crate mill_lang_shell;
    #[cfg(all(test, feature = "lang-svelte"))]
    extern crate mill_lang_svelte;
    #[cfg(all(test, feature = "lang-toml"))]
    extern crate mill_lang_toml;
    #[cfg(all(test, feature = "lang-typescript"))]
    extern crate mill_lang_typescript;
    #[cfg(all(test, feature = "lang-yaml"))]
    extern crate mill_lang_yaml;
    #[cfg(all(test, feature = "lang-zig"))]
    extern crate mill_lang_zig;

    #[test]
    fn test_all_plugins_returns_plugins() {
        let plugins = all_plugins();
        assert!(
            plugins.len() >= 3,
            "Expected at least 3 plugins (Rust, TypeScript, Markdown), found {}",
            plugins.len()
        );
    }

    #[test]
    fn test_plugins_have_unique_names() {
        let plugins = all_plugins();
        let mut names = std::collections::HashSet::new();
        for plugin in plugins {
            let name = plugin.metadata().name;
            assert!(names.insert(name), "Duplicate plugin name found: {}", name);
        }
    }
}
