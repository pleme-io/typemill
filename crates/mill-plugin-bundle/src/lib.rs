//! Language Plugin Bundle
//!
//! This file is AUTO-GENERATED by `cargo xtask sync-languages`.
//! Do not edit manually - changes will be overwritten.
//!
//! To add a new language:
//! 1. Add entry to languages.toml
//! 2. Run: cargo xtask sync-languages

use mill_plugin_api::{iter_plugins, LanguagePlugin};
use std::sync::Arc;

// Force linker to include language plugins by actively using them.
// This prevents linker dead code elimination from stripping the inventory submissions.
// We reference each plugin's public type to ensure the crate is linked.
#[cfg(feature = "lang-c")]
use mill_lang_c::CPlugin;
#[cfg(feature = "lang-cpp")]
use mill_lang_cpp::CppPlugin;
#[cfg(feature = "lang-csharp")]
use mill_lang_csharp::CsharpPlugin;
#[cfg(feature = "lang-gitignore")]
use mill_lang_gitignore::GitignoreLanguagePlugin;
#[cfg(feature = "lang-go")]
use mill_lang_go::GoPlugin;
#[cfg(feature = "lang-java")]
use mill_lang_java::JavaPlugin;
#[cfg(feature = "lang-markdown")]
use mill_lang_markdown::MarkdownPlugin;
#[cfg(feature = "lang-python")]
use mill_lang_python::PythonPlugin;
#[cfg(feature = "lang-rust")]
use mill_lang_rust::RustPlugin;
#[cfg(feature = "lang-swift")]
use mill_lang_swift::SwiftPlugin;
#[cfg(feature = "lang-toml")]
use mill_lang_toml::TomlLanguagePlugin;
#[cfg(feature = "lang-typescript")]
use mill_lang_typescript::TypeScriptPlugin;
#[cfg(feature = "lang-yaml")]
use mill_lang_yaml::YamlLanguagePlugin;

// This function ensures the linker includes all plugin crates
// Called from all_plugins() to force linkage before inventory discovery
#[inline(never)]
fn _force_plugin_linkage() {
    // Use black_box to prevent compiler from optimizing away type references
    // This ensures plugin crates are linked even in release builds
    #[cfg(feature = "lang-c")]
    std::hint::black_box(std::any::type_name::<CPlugin>());
    #[cfg(feature = "lang-cpp")]
    std::hint::black_box(std::any::type_name::<CppPlugin>());
    #[cfg(feature = "lang-csharp")]
    std::hint::black_box(std::any::type_name::<CsharpPlugin>());
    #[cfg(feature = "lang-gitignore")]
    std::hint::black_box(std::any::type_name::<GitignoreLanguagePlugin>());
    #[cfg(feature = "lang-go")]
    std::hint::black_box(std::any::type_name::<GoPlugin>());
    #[cfg(feature = "lang-java")]
    std::hint::black_box(std::any::type_name::<JavaPlugin>());
    #[cfg(feature = "lang-markdown")]
    std::hint::black_box(std::any::type_name::<MarkdownPlugin>());
    #[cfg(feature = "lang-python")]
    std::hint::black_box(std::any::type_name::<PythonPlugin>());
    #[cfg(feature = "lang-rust")]
    std::hint::black_box(std::any::type_name::<RustPlugin>());
    #[cfg(feature = "lang-swift")]
    std::hint::black_box(std::any::type_name::<SwiftPlugin>());
    #[cfg(feature = "lang-toml")]
    std::hint::black_box(std::any::type_name::<TomlLanguagePlugin>());
    #[cfg(feature = "lang-typescript")]
    std::hint::black_box(std::any::type_name::<TypeScriptPlugin>());
    #[cfg(feature = "lang-yaml")]
    std::hint::black_box(std::any::type_name::<YamlLanguagePlugin>());
}

/// Returns all language plugins available in this bundle.
///
/// This function uses the plugin registry's auto-discovery mechanism
/// to find all plugins that have self-registered using the `mill_plugin!` macro.
pub fn all_plugins() -> Vec<Arc<dyn LanguagePlugin>> {
    // Force linker to include all plugin crates before inventory discovery
    // This ensures plugins are available for inventory to find
    _force_plugin_linkage();

    let plugins: Vec<_> = iter_plugins()
        .map(|descriptor| {
            tracing::debug!(
                plugin_name = descriptor.name,
                extensions = ?descriptor.extensions,
                "Discovered language plugin via inventory"
            );
            let plugin = (descriptor.factory)();
            Arc::from(plugin) as Arc<dyn LanguagePlugin>
        })
        .collect();

    tracing::info!(
        plugin_count = plugins.len(),
        "Language plugin bundle discovery complete"
    );

    if plugins.is_empty() {
        tracing::warn!("No language plugins discovered - inventory system may be broken");
    }

    plugins
}

#[cfg(test)]
mod tests {
    use super::*;

    // Force linker to include language plugins for inventory collection in tests
    #[cfg(all(test, feature = "lang-c"))]
    extern crate mill_lang_c;
    #[cfg(all(test, feature = "lang-cpp"))]
    extern crate mill_lang_cpp;
    #[cfg(all(test, feature = "lang-csharp"))]
    extern crate mill_lang_csharp;
    #[cfg(all(test, feature = "lang-gitignore"))]
    extern crate mill_lang_gitignore;
    #[cfg(all(test, feature = "lang-go"))]
    extern crate mill_lang_go;
    #[cfg(all(test, feature = "lang-java"))]
    extern crate mill_lang_java;
    #[cfg(all(test, feature = "lang-markdown"))]
    extern crate mill_lang_markdown;
    #[cfg(all(test, feature = "lang-python"))]
    extern crate mill_lang_python;
    #[cfg(all(test, feature = "lang-rust"))]
    extern crate mill_lang_rust;
    #[cfg(all(test, feature = "lang-swift"))]
    extern crate mill_lang_swift;
    #[cfg(all(test, feature = "lang-toml"))]
    extern crate mill_lang_toml;
    #[cfg(all(test, feature = "lang-typescript"))]
    extern crate mill_lang_typescript;
    #[cfg(all(test, feature = "lang-yaml"))]
    extern crate mill_lang_yaml;

    #[test]
    fn test_all_plugins_returns_plugins() {
        let plugins = all_plugins();
        assert!(
            plugins.len() >= 3,
            "Expected at least 3 plugins (Rust, TypeScript, Markdown), found {}",
            plugins.len()
        );
    }

    #[test]
    fn test_plugins_have_unique_names() {
        let plugins = all_plugins();
        let mut names = std::collections::HashSet::new();
        for plugin in plugins {
            let name = plugin.metadata().name;
            assert!(names.insert(name), "Duplicate plugin name found: {}", name);
        }
    }
}