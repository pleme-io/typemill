// Build script for code generation from languages.toml
//
// This script reads languages.toml and generates:
// 1. ProjectLanguage enum variants (for cb-core)
// 2. LanguageMetadata constants (for cb-plugin-api)
// 3. Workspace Cargo.toml snippet (for root Cargo.toml)
// 4. Registry registration code (for cb-services)

use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, serde::Deserialize)]
struct LanguagesConfig {
    languages: BTreeMap<String, LanguageEntry>,
}

#[derive(Debug, serde::Deserialize)]
struct LanguageEntry {
    display_name: String,
    extensions: Vec<String>,
    manifest_filename: String,
    source_dir: String,
    entry_point: String,
    module_separator: String,
    crate_name: String,
    feature_name: String,
}

fn main() {
    // Path to languages.toml relative to workspace root
    let config_path = PathBuf::from("../languages/languages.toml");

    // Tell Cargo to rerun this script if languages.toml changes
    println!("cargo:rerun-if-changed=../languages/languages.toml");

    let config_content = fs::read_to_string(&config_path)
        .expect("Failed to read languages.toml (expected at crates/languages/languages.toml)");

    let config: LanguagesConfig = toml::from_str(&config_content)
        .expect("Failed to parse languages.toml");

    // Get output directory for generated files
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Generate each component
    generate_language_enum(&config, &out_dir);
    generate_metadata_constants(&config, &out_dir);
    generate_cargo_dependencies(&config, &out_dir);
    generate_registry_registration(&config, &out_dir);
}

fn generate_language_enum(config: &LanguagesConfig, out_dir: &PathBuf) {
    let mut output = String::from(
        "// Generated by build.rs from languages.toml - DO NOT EDIT\n\
        \n\
        /// Supported project languages\n\
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n\
        pub enum ProjectLanguage {\n"
    );

    // Generate enum variants (use key directly as variant name)
    for (key, entry) in &config.languages {
        output.push_str(&format!(
            "    /// {} projects ({})\n",
            entry.display_name, entry.manifest_filename
        ));
        output.push_str(&format!("    {},\n", key));
    }

    output.push_str("    /// Unknown or mixed-language project\n");
    output.push_str("    Unknown,\n");
    output.push_str("}\n\n");

    // Generate as_str() method
    output.push_str("impl ProjectLanguage {\n");
    output.push_str("    /// Get the string representation of the language\n");
    output.push_str("    pub fn as_str(&self) -> &'static str {\n");
    output.push_str("        match self {\n");

    for (key, _) in &config.languages {
        output.push_str(&format!(
            "            ProjectLanguage::{} => \"{}\",\n",
            key, key.to_lowercase()
        ));
    }

    output.push_str("            ProjectLanguage::Unknown => \"unknown\",\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Generate manifest_filename() method
    output.push_str("    /// Get the primary manifest filename for this language\n");
    output.push_str("    pub fn manifest_filename(&self) -> &'static str {\n");
    output.push_str("        match self {\n");

    for (key, entry) in &config.languages {
        output.push_str(&format!(
            "            ProjectLanguage::{} => \"{}\",\n",
            key, entry.manifest_filename
        ));
    }

    output.push_str("            ProjectLanguage::Unknown => \"\",\n");
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    fs::write(out_dir.join("language_enum.rs"), output)
        .expect("Failed to write language_enum.rs");
}

fn generate_metadata_constants(config: &LanguagesConfig, out_dir: &PathBuf) {
    let mut output = String::from(
        "// Generated by build.rs from languages.toml - DO NOT EDIT\n\n\
        impl LanguageMetadata {\n"
    );

    for (key, entry) in &config.languages {
        let const_name = key.to_uppercase();

        // Format extensions array
        let extensions = entry
            .extensions
            .iter()
            .map(|ext| format!("\"{}\"", ext))
            .collect::<Vec<_>>()
            .join(", ");

        output.push_str(&format!(
            "    /// {} language metadata constant\n",
            entry.display_name
        ));
        output.push_str(&format!("    pub const {}: Self = Self {{\n", const_name));
        output.push_str(&format!("        name: \"{}\",\n", entry.display_name));
        output.push_str(&format!("        extensions: &[{}],\n", extensions));
        output.push_str(&format!(
            "        manifest_filename: \"{}\",\n",
            entry.manifest_filename
        ));
        output.push_str(&format!("        source_dir: \"{}\",\n", entry.source_dir));
        output.push_str(&format!("        entry_point: \"{}\",\n", entry.entry_point));
        output.push_str(&format!(
            "        module_separator: \"{}\",\n",
            entry.module_separator
        ));
        output.push_str(&format!("        language: ProjectLanguage::{},\n", key));
        output.push_str("    };\n\n");
    }

    output.push_str("}\n");

    fs::write(out_dir.join("metadata_constants.rs"), output)
        .expect("Failed to write metadata_constants.rs");
}

fn generate_cargo_dependencies(config: &LanguagesConfig, out_dir: &PathBuf) {
    let mut output = String::from("# Generated by build.rs from languages.toml - DO NOT EDIT\n");
    output.push_str("# Language plugins\n");

    for (_key, entry) in &config.languages {
        output.push_str(&format!(
            "{} = {{ path = \"crates/languages/{}\" }}\n",
            entry.crate_name, entry.crate_name
        ));
    }

    fs::write(out_dir.join("cargo_dependencies.toml"), output)
        .expect("Failed to write cargo_dependencies.toml");
}

fn generate_registry_registration(config: &LanguagesConfig, out_dir: &PathBuf) {
    let mut output = String::from(
        "// Generated by build.rs from languages.toml - DO NOT EDIT\n\n"
    );

    for (key, entry) in &config.languages {
        let struct_name = format!("{}Plugin", key);
        let crate_ident = entry.crate_name.replace("-", "_");

        output.push_str(&format!("    // Register {} plugin\n", entry.display_name));
        output.push_str(&format!(
            "    #[cfg(feature = \"{}\")]\n",
            entry.feature_name
        ));
        output.push_str("    {\n");
        output.push_str(&format!(
            "        registry.register(Arc::new({}::{}::new()));\n",
            crate_ident, struct_name
        ));
        output.push_str("        plugin_count += 1;\n");
        output.push_str("    }\n\n");
    }

    fs::write(out_dir.join("registry_registration.rs"), output)
        .expect("Failed to write registry_registration.rs");
}
