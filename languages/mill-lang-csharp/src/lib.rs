//! C# Language Plugin for TypeMill
//!
//! Provides AST parsing, symbol extraction, and manifest analysis for C#.

mod constants;
pub mod import_support;
pub mod lsp_installer;
pub mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_foundation::protocol::EditPlan;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics, CodeRange,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater, ModuleReferenceScanner,
    ParsedSource, PluginError, PluginResult, RefactoringProvider,
};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: CsharpPlugin,
    name: "csharp",
    extensions: ["cs"],
    manifest: ".csproj",
    lsp_command: "csharp-ls",
    lsp_args: [""],
    source_dir: ".",
    entry_point: "Program.cs",
    module_separator: ".",
    capabilities: [with_imports, with_project_factory, with_workspace],
    fields: {
        import_support: import_support::CsharpImportSupport,
        project_factory: project_factory::CsharpProjectFactory,
        workspace_support: workspace_support::CsharpWorkspaceSupport,
        lsp_installer: lsp_installer::CsharpLspInstaller,
    },
    doc: "C# language plugin implementation providing comprehensive C# language support"
}

#[async_trait]
impl LanguagePlugin for CsharpPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl RefactoringProvider for CsharpPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        // The original implementation used a CodeRange. We will create one here
        // to pass to the existing logic, assuming column 0 to end-of-line.
        let end_col = source
            .lines()
            .nth(end_line as usize)
            .map(|l| l.len() as u32)
            .ok_or_else(|| {
                PluginError::invalid_input(format!("Line {} exceeds source length", end_line))
            })?;

        let range = CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col,
        };
        self::refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }
}

impl ModuleReferenceScanner for CsharpPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        use mill_plugin_api::{ModuleReference, ReferenceKind, ScanScope};
        let mut references = Vec::new();

        for (line_idx, line) in content.lines().enumerate() {
            let line_num = line_idx + 1;

            // Skip lines that are comments
            if constants::is_in_multiline_comment(line) {
                continue;
            }

            // Strip inline comments before processing
            let code_only = constants::strip_single_line_comments(line);

            // Scan for `using module_name;` with word boundaries
            if scope != ScanScope::QualifiedPaths {
                let using_re = (constants::USING_STATEMENT_PATTERN)(module_name);
                if let Some(mat) = using_re.find(code_only) {
                    // Skip if this is a using alias (contains '=')
                    if !code_only[mat.start()..].contains('=') {
                        references.push(ModuleReference {
                            line: line_num,
                            column: mat.start() + 6, // After "using "
                            length: module_name.len(),
                            text: module_name.to_string(),
                            kind: ReferenceKind::Declaration,
                        });
                    }
                }
            }

            // Scan for qualified paths like `module_name.Class`
            if scope == ScanScope::QualifiedPaths || scope == ScanScope::All {
                let qualified_pattern = (constants::QUALIFIED_PATH_PATTERN)(module_name);
                let qualified_re = regex::Regex::new(&qualified_pattern)
                    .map_err(|e| PluginError::internal(format!("Invalid regex: {}", e)))?;

                for mat in qualified_re.find_iter(code_only) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::QualifiedPath,
                    });
                }
            }

            // Scan for string literals (e.g., for reflection)
            if scope == ScanScope::All {
                let string_pattern = (constants::STRING_LITERAL_PATTERN)(module_name);
                if let Some(col) = code_only.find(&string_pattern) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: col + 1, // Skip opening quote
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::StringLiteral,
                    });
                }
            }
        }

        Ok(references)
    }
}

use chrono::Utc;
use mill_foundation::protocol::{ImportGraphMetadata, ImportInfo, ImportType};

impl ImportAnalyzer for CsharpPlugin {
    fn build_import_graph(
        &self,
        file_path: &Path,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        let content = std::fs::read_to_string(file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(format!("Failed to read file: {}", e)))?;

        let imports = parser::parse_source(&content)?
            .symbols
            .into_iter()
            .filter(|s| s.kind == mill_plugin_api::SymbolKind::Module)
            .map(|s| {
                let api_loc = s.location;
                let protocol_loc = mill_foundation::protocol::SourceLocation {
                    start_line: api_loc.line as u32,
                    start_column: api_loc.column as u32,
                    end_line: api_loc.line as u32,
                    end_column: api_loc.column as u32,
                };
                ImportInfo {
                    module_path: s.name,
                    import_type: ImportType::Namespace,
                    named_imports: vec![],
                    default_import: None,
                    namespace_import: None,
                    type_only: false,
                    location: protocol_loc,
                }
            })
            .collect();

        Ok(mill_foundation::protocol::ImportGraph {
            source_file: file_path
                .to_str()
                .ok_or_else(|| {
                    PluginError::internal(format!("Invalid file path: {:?}", file_path))
                })?
                .to_string(),
            imports,
            importers: vec![], // This would be populated by a workspace-wide analysis
            metadata: ImportGraphMetadata {
                language: self.metadata().name.to_string(),
                parsed_at: Utc::now(),
                parser_version: constants::CSHARP_PARSER_VERSION.to_string(),
                circular_dependencies: vec![],
                external_dependencies: vec![],
            },
        })
    }
}

#[async_trait]
impl ManifestUpdater for CsharpPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = tokio::fs::read_to_string(manifest_path).await
            .map_err(|e| mill_plugin_api::PluginError::internal(format!("Failed to read manifest: {}", e)))?;

        manifest::update_package_reference(&content, old_name, new_name, new_version)
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        manifest::generate_csproj(package_name, dependencies)
    }
}

impl mill_plugin_api::AnalysisMetadata for CsharpPlugin {
    fn test_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"\[Test\]").unwrap(),
            regex::Regex::new(r"\[Fact\]").unwrap(),
            regex::Regex::new(r"\[Theory\]").unwrap(),
            regex::Regex::new(r"\[TestMethod\]").unwrap(),
        ]
    }

    fn assertion_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"Assert\.").unwrap(),
            regex::Regex::new(r"Assert\.Equal").unwrap(),
            regex::Regex::new(r"Assert\.True").unwrap(),
            regex::Regex::new(r"\.Should\(\)").unwrap(),
        ]
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::TripleSlash
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec!["public", "private", "protected", "internal", "protected internal", "private protected"]
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["interface", "class", "struct", "enum", "record"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec!["if", "else", "switch", "case", "for", "foreach", "while", "catch", "&&", "||", "??"]
    }

    fn nesting_penalty(&self) -> f32 {
        1.3
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{CreatePackageConfig, PackageType, ScanScope, Template};
    use std::io::Write;
    use tempfile::{tempdir, NamedTempFile};

    #[tokio::test]
    async fn test_csharp_plugin_basic() {
        let plugin = CsharpPlugin::new();
        assert_eq!(plugin.metadata().name, "csharp");
        assert_eq!(plugin.metadata().extensions, &["cs"]);
        assert!(plugin.handles_extension("cs"));
        assert!(!plugin.handles_extension("rs"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_handles_manifests() {
        let plugin = CsharpPlugin::new();
        assert!(plugin.handles_manifest(".csproj"));
        assert!(!plugin.handles_manifest("Cargo.toml"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_capabilities() {
        let plugin = CsharpPlugin::new();
        let caps = plugin.capabilities();
        assert!(caps.imports);
        assert!(caps.project_factory);
        assert!(caps.workspace);
        assert!(plugin.refactoring_provider().is_some());
        assert!(plugin.module_reference_scanner().is_some());
        assert!(plugin.import_analyzer().is_some());
        assert!(plugin.manifest_updater().is_some());
        assert!(plugin.lsp_installer().is_some());
    }

    #[tokio::test]
    async fn test_create_package() {
        let plugin = CsharpPlugin::new();
        let factory = plugin.project_factory().unwrap();
        let temp_dir = tempdir().unwrap();
        let config = CreatePackageConfig {
            workspace_root: temp_dir.path().to_str().unwrap().to_string(),
            package_path: "MyTestCsharpApp".to_string(),
            package_type: PackageType::Library,
            template: Template::default(),
            add_to_workspace: false,
        };

        let result = factory.create_package(&config);

        // This test requires `dotnet` to be installed on the system.
        if std::process::Command::new("dotnet").output().is_err() {
            println!("Skipping `test_create_package` because `dotnet` is not installed.");
            return;
        }

        assert!(result.is_ok(), "create_package failed: {:?}", result.err());
        let pkg = result.unwrap();
        assert!(!pkg.created_files.is_empty());
        let manifest_path = pkg.package_info.manifest_path;
        assert!(Path::new(&manifest_path).exists());
        assert_eq!(
            Path::new(&manifest_path)
                .file_name()
                .unwrap()
                .to_str()
                .unwrap(),
            "MyTestCsharpApp.csproj"
        );
    }

    #[test]
    fn test_workspace_support() {
        let plugin = CsharpPlugin::new();
        let support = plugin.workspace_support().unwrap();
        let sln_content = r#"
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyWebApp", "MyWebApp\MyWebApp.csproj", "{GUID1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{GUID1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
	EndGlobalSection
EndGlobal
"#;
        let members = support.list_workspace_members(sln_content);
        assert_eq!(members, vec!["MyWebApp\\MyWebApp.csproj"]);

        let new_sln = support.add_workspace_member(sln_content, "NewApp\\NewApp.csproj");
        assert!(new_sln.contains("NewApp"));

        let final_sln = support.remove_workspace_member(&new_sln, "MyWebApp\\MyWebApp.csproj");
        assert!(!final_sln.contains("MyWebApp"));
    }

    #[test]
    fn test_module_reference_scanner() {
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = r#"
using System;
using System.Collections.Generic;

namespace MyNamespace
{
    public class MyClass
    {
        public void DoSomething()
        {
            var list = new System.Collections.Generic.List<int>();
            var type = "System.Text";
        }
    }
}
"#;
        let refs = scanner
            .scan_references(content, "System.Collections.Generic", ScanScope::All)
            .unwrap();
        assert_eq!(refs.len(), 2);
    }

    #[tokio::test]
    async fn test_import_analyzer() {
        let plugin = CsharpPlugin::new();
        let analyzer = plugin.import_analyzer().unwrap();
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "using System;\nusing System.Text;").unwrap();

        let graph = analyzer.build_import_graph(temp_file.path()).unwrap();
        assert_eq!(graph.imports.len(), 2);
        assert!(graph
            .imports
            .iter()
            .any(|i| i.module_path == "System"));
    }

    #[tokio::test]
    async fn test_manifest_updater() {
        let plugin = CsharpPlugin::new();
        let updater = plugin.manifest_updater().unwrap();
        let csproj_content = r#"
<Project Sdk="Microsoft.NET.Sdk">
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>
</Project>
"#;
        let mut temp_file = NamedTempFile::new().unwrap();
        write!(temp_file, "{}", csproj_content).unwrap();

        let updated_content = updater
            .update_dependency(
                temp_file.path(),
                "Newtonsoft.Json",
                "Newtonsoft.Json",
                Some("13.0.2"),
            )
            .await
            .unwrap();

        assert!(updated_content.contains("13.0.2"));
    }

    #[test]
    fn test_lsp_installer() {
        let plugin = CsharpPlugin::new();
        let installer = plugin.lsp_installer().unwrap();
        assert_eq!(installer.lsp_name(), "csharp-ls");
        // We can't easily test the installation itself, but we can check the name
    }

    #[test]
    fn test_analysis_metadata_test_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let patterns = plugin.test_patterns();

        // Should match NUnit test attribute
        let nunit_sample = "[Test]\npublic void MyTest() {}";
        assert!(patterns.iter().any(|p| p.is_match(nunit_sample)));

        // Should match xUnit fact attribute
        let xunit_sample = "[Fact]\npublic void MyFact() {}";
        assert!(patterns.iter().any(|p| p.is_match(xunit_sample)));

        // Should match MSTest attribute
        let mstest_sample = "[TestMethod]\npublic void MyMethod() {}";
        assert!(patterns.iter().any(|p| p.is_match(mstest_sample)));
    }

    #[test]
    fn test_analysis_metadata_assertion_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let patterns = plugin.assertion_patterns();

        // Should match Assert.Equal
        let assert_sample = "Assert.Equal(expected, actual);";
        assert!(patterns.iter().any(|p| p.is_match(assert_sample)));

        // Should match Assert.True
        let true_sample = "Assert.True(condition);";
        assert!(patterns.iter().any(|p| p.is_match(true_sample)));

        // Should match FluentAssertions
        let fluent_sample = "result.Should().Be(expected);";
        assert!(patterns.iter().any(|p| p.is_match(fluent_sample)));
    }

    #[test]
    fn test_analysis_metadata_complexity_keywords() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let keywords = plugin.complexity_keywords();

        // Should include C# control flow keywords
        assert!(keywords.contains(&"if"));
        assert!(keywords.contains(&"else"));
        assert!(keywords.contains(&"switch"));
        assert!(keywords.contains(&"case"));
        assert!(keywords.contains(&"for"));
        assert!(keywords.contains(&"foreach"));
        assert!(keywords.contains(&"while"));
        assert!(keywords.contains(&"catch"));
        assert!(keywords.contains(&"??"));

        // Check nesting penalty
        assert_eq!(plugin.nesting_penalty(), 1.3);
    }

    // ========================================================================
    // EDGE CASE TESTS (8 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_edge_parse_unicode_identifiers() {
        let plugin = CsharpPlugin::new();
        let source = r#"
using System.Collections.Generic;
class Main {
    void тестфункция() {
        int مُتَغَيِّر = 42;
    }
}
"#;
        let result = plugin.parse(source).await;
        // Should not panic with Unicode identifiers
        assert!(result.is_ok() || result.is_err()); // Either way, no panic
    }

    #[tokio::test]
    async fn test_edge_parse_extremely_long_line() {
        let plugin = CsharpPlugin::new();
        let long_string = "a".repeat(15000);
        let source = format!("class Main {{ string x = \"{}\"; }}\n", long_string);
        let result = plugin.parse(&source).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_edge_parse_no_newlines() {
        let plugin = CsharpPlugin::new();
        let source = "class Main { static void Main() { Console.WriteLine(\"hello\"); } }";
        let result = plugin.parse(source).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_edge_scan_mixed_line_endings() {
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "using System.Collections.Generic;\r\nusing System.Linq;\nusing System.IO;";
        let refs = scanner.scan_references(content, "System.Collections.Generic", ScanScope::All).expect("Should scan");
        assert_eq!(refs.len(), 1);
    }

    #[tokio::test]
    async fn test_edge_parse_empty_file() {
        let plugin = CsharpPlugin::new();
        let result = plugin.parse("").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[tokio::test]
    async fn test_edge_parse_whitespace_only() {
        let plugin = CsharpPlugin::new();
        let result = plugin.parse("   \n\n\t\t\n   ").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[test]
    fn test_edge_scan_special_regex_chars() {
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "using System.Collections.Generic;";
        // Test with special regex characters
        let result = scanner.scan_references(content, "System.*", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    #[test]
    fn test_edge_handle_null_bytes() {
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "using System.Collections.Generic;\x00\nusing System.Linq;";
        let result = scanner.scan_references(content, "System.Collections.Generic", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = CsharpPlugin::new();

        // Create a large C# file (~100KB, 5000 methods)
        let mut large_source = String::from("using System.Collections.Generic;\n\nclass Large {\n");
        for i in 0..5000 {
            large_source.push_str(&format!("    public int Method{}() {{ return {}; }}\n", i, i));
        }
        large_source.push_str("}\n");

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new().unwrap().block_on(async {
            plugin.parse(&large_source).await
        });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert!(symbols.len() >= 5000, "Should find at least 5000 methods");
        assert!(duration.as_secs() < 5, "Should parse within 5 seconds, took {:?}", duration);
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("using System.Collections.Generic;\n\n");
        for _ in 0..10000 {
            content.push_str("System.Collections.Generic.List<int> list = new System.Collections.Generic.List<int>();\n");
        }

        let start = Instant::now();
        let refs = scanner.scan_references(&content, "System.Collections.Generic", ScanScope::All).expect("Should scan");
        let duration = start.elapsed();

        assert!(refs.len() >= 10001, "Should find using + qualified paths");
        assert!(duration.as_secs() < 10, "Should scan within 10 seconds, took {:?}", duration);
    }
}