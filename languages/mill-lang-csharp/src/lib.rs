//! C# Language Plugin for TypeMill
//!
//! Provides AST parsing, symbol extraction, and manifest analysis for C#.

mod constants;
pub mod import_support;
pub mod lsp_installer;
pub mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_foundation::protocol::EditPlan;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics, CodeRange,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater, ModuleReferenceScanner,
    ParsedSource, PluginApiError, PluginResult, RefactoringProvider,
};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: CsharpPlugin,
    name: "csharp",
    extensions: ["cs"],
    manifest: ".csproj",
    lsp_command: "csharp-ls",
    lsp_args: [""],
    source_dir: ".",
    entry_point: "Program.cs",
    module_separator: ".",
    capabilities: [with_imports, with_project_factory, with_workspace],
    fields: {
        import_support: import_support::CsharpImportSupport,
        project_factory: project_factory::CsharpProjectFactory,
        workspace_support: workspace_support::CsharpWorkspaceSupport,
        lsp_installer: lsp_installer::CsharpLspInstaller,
    },
    doc: "C# language plugin implementation providing comprehensive C# language support"
}

#[async_trait]
impl LanguagePlugin for CsharpPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl RefactoringProvider for CsharpPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        // The original implementation used a CodeRange. We will create one here
        // to pass to the existing logic, assuming column 0 to end-of-line.
        let end_col = source
            .lines()
            .nth(end_line as usize)
            .map(|l| l.len() as u32)
            .ok_or_else(|| {
                PluginApiError::invalid_input(format!("Line {} exceeds source length", end_line))
            })?;

        let range = CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col,
        };
        self::refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        self::refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }
}

impl ModuleReferenceScanner for CsharpPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        use mill_plugin_api::{ModuleReference, ReferenceKind, ScanScope};
        let mut references = Vec::new();

        // Compile using pattern regex once outside the loop for performance
        let using_re = if scope != ScanScope::QualifiedPaths {
            Some((constants::USING_STATEMENT_PATTERN)(module_name))
        } else {
            None
        };

        // Compile qualified path regex once outside the loop for performance
        let qualified_re = if scope == ScanScope::QualifiedPaths || scope == ScanScope::All {
            let qualified_pattern = (constants::QUALIFIED_PATH_PATTERN)(module_name);
            Some(
                regex::Regex::new(&qualified_pattern)
                    .map_err(|e| PluginApiError::internal(format!("Invalid regex: {}", e)))?,
            )
        } else {
            None
        };

        for (line_idx, line) in content.lines().enumerate() {
            let line_num = line_idx + 1;

            // Skip lines that are comments
            if constants::is_in_multiline_comment(line) {
                continue;
            }

            // Strip inline comments before processing
            let code_only = constants::strip_single_line_comments(line);

            // Scan for `using module_name;` with word boundaries
            if let Some(ref using_re) = using_re {
                if let Some(mat) = using_re.find(code_only) {
                    // Skip if this is a using alias (contains '=')
                    if !code_only[mat.start()..].contains('=') {
                        references.push(ModuleReference {
                            line: line_num,
                            column: mat.start() + 6, // After "using "
                            length: module_name.len(),
                            text: module_name.to_string(),
                            kind: ReferenceKind::Declaration,
                        });
                    }
                }
            }

            // Scan for qualified paths like `module_name.Class`
            if let Some(ref qualified_re) = qualified_re {
                for mat in qualified_re.find_iter(code_only) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::QualifiedPath,
                    });
                }
            }

            // Scan for string literals (e.g., for reflection)
            if scope == ScanScope::All {
                let string_pattern = (constants::STRING_LITERAL_PATTERN)(module_name);
                if let Some(col) = code_only.find(&string_pattern) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: col + 1, // Skip opening quote
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::StringLiteral,
                    });
                }
            }
        }

        Ok(references)
    }
}

use chrono::Utc;
use mill_foundation::protocol::{ImportGraphMetadata, ImportInfo, ImportType};

impl ImportAnalyzer for CsharpPlugin {
    fn build_import_graph(
        &self,
        file_path: &Path,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        let content = std::fs::read_to_string(file_path).map_err(|e| {
            mill_plugin_api::PluginApiError::internal(format!("Failed to read file: {}", e))
        })?;

        let imports = parser::parse_source(&content)?
            .symbols
            .into_iter()
            .filter(|s| s.kind == mill_plugin_api::SymbolKind::Module)
            .map(|s| {
                let api_loc = s.location;
                let protocol_loc = mill_foundation::protocol::SourceLocation {
                    start_line: api_loc.line as u32,
                    start_column: api_loc.column as u32,
                    end_line: api_loc.line as u32,
                    end_column: api_loc.column as u32,
                };
                ImportInfo {
                    module_path: s.name,
                    import_type: ImportType::Namespace,
                    named_imports: vec![],
                    default_import: None,
                    namespace_import: None,
                    type_only: false,
                    location: protocol_loc,
                }
            })
            .collect();

        Ok(mill_foundation::protocol::ImportGraph {
            source_file: file_path
                .to_str()
                .ok_or_else(|| {
                    PluginApiError::internal(format!("Invalid file path: {:?}", file_path))
                })?
                .to_string(),
            imports,
            importers: vec![], // This would be populated by a workspace-wide analysis
            metadata: ImportGraphMetadata {
                language: self.metadata().name.to_string(),
                parsed_at: Utc::now(),
                parser_version: constants::CSHARP_PARSER_VERSION.to_string(),
                circular_dependencies: vec![],
                external_dependencies: vec![],
            },
        })
    }
}

#[async_trait]
impl ManifestUpdater for CsharpPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = tokio::fs::read_to_string(manifest_path)
            .await
            .map_err(|e| {
                mill_plugin_api::PluginApiError::internal(format!("Failed to read manifest: {}", e))
            })?;

        manifest::update_package_reference(&content, old_name, new_name, new_version)
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        manifest::generate_csproj(package_name, dependencies)
    }
}

impl mill_plugin_api::AnalysisMetadata for CsharpPlugin {
    fn test_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"\[Test\]").unwrap(),
            regex::Regex::new(r"\[Fact\]").unwrap(),
            regex::Regex::new(r"\[Theory\]").unwrap(),
            regex::Regex::new(r"\[TestMethod\]").unwrap(),
        ]
    }

    fn assertion_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"Assert\.").unwrap(),
            regex::Regex::new(r"Assert\.Equal").unwrap(),
            regex::Regex::new(r"Assert\.True").unwrap(),
            regex::Regex::new(r"\.Should\(\)").unwrap(),
        ]
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::TripleSlash
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec![
            "public",
            "private",
            "protected",
            "internal",
            "protected internal",
            "private protected",
        ]
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["interface", "class", "struct", "enum", "record"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec![
            "if", "else", "switch", "case", "for", "foreach", "while", "catch", "&&", "||", "??",
        ]
    }

    fn nesting_penalty(&self) -> f32 {
        1.3
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{CreatePackageConfig, PackageType, ScanScope, Template};
    use std::io::Write;
    use tempfile::{tempdir, NamedTempFile};

    #[tokio::test]
    async fn test_csharp_plugin_basic() {
        let plugin = CsharpPlugin::new();
        assert_eq!(plugin.metadata().name, "csharp");
        assert_eq!(plugin.metadata().extensions, &["cs"]);
        assert!(plugin.handles_extension("cs"));
        assert!(!plugin.handles_extension("rs"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_handles_manifests() {
        let plugin = CsharpPlugin::new();
        assert!(plugin.handles_manifest(".csproj"));
        assert!(!plugin.handles_manifest("Cargo.toml"));
    }

    #[tokio::test]
    async fn test_csharp_plugin_capabilities() {
        let plugin = CsharpPlugin::new();
        let caps = plugin.capabilities();
        assert!(caps.imports);
        assert!(caps.project_factory);
        assert!(caps.workspace);
        assert!(plugin.refactoring_provider().is_some());
        assert!(plugin.module_reference_scanner().is_some());
        assert!(plugin.import_analyzer().is_some());
        assert!(plugin.manifest_updater().is_some());
        assert!(plugin.lsp_installer().is_some());
    }

    #[tokio::test]
    async fn test_create_package() {
        let plugin = CsharpPlugin::new();
        let factory = plugin.project_factory().unwrap();
        let temp_dir = tempdir().unwrap();
        let config = CreatePackageConfig {
            workspace_root: temp_dir.path().to_str().unwrap().to_string(),
            package_path: "MyTestCsharpApp".to_string(),
            package_type: PackageType::Library,
            template: Template::default(),
            add_to_workspace: false,
        };

        let result = factory.create_package(&config);

        // This test requires `dotnet` to be installed on the system.
        if std::process::Command::new("dotnet").output().is_err() {
            println!("Skipping `test_create_package` because `dotnet` is not installed.");
            return;
        }

        assert!(result.is_ok(), "create_package failed: {:?}", result.err());
        let pkg = result.unwrap();
        assert!(!pkg.created_files.is_empty());
        let manifest_path = pkg.package_info.manifest_path;
        assert!(Path::new(&manifest_path).exists());
        assert_eq!(
            Path::new(&manifest_path)
                .file_name()
                .unwrap()
                .to_str()
                .unwrap(),
            "MyTestCsharpApp.csproj"
        );
    }

    #[test]
    fn test_workspace_support() {
        let plugin = CsharpPlugin::new();
        let support = plugin.workspace_support().unwrap();
        let sln_content = r#"
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyWebApp", "MyWebApp\MyWebApp.csproj", "{GUID1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{GUID1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
	EndGlobalSection
EndGlobal
"#;
        let members = support.list_workspace_members(sln_content);
        assert_eq!(members, vec!["MyWebApp\\MyWebApp.csproj"]);

        let new_sln = support.add_workspace_member(sln_content, "NewApp\\NewApp.csproj");
        assert!(new_sln.contains("NewApp"));

        let final_sln = support.remove_workspace_member(&new_sln, "MyWebApp\\MyWebApp.csproj");
        assert!(!final_sln.contains("MyWebApp"));
    }

    #[test]
    fn test_module_reference_scanner() {
        let plugin = CsharpPlugin::new();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = r#"
using System;
using System.Collections.Generic;

namespace MyNamespace
{
    public class MyClass
    {
        public void DoSomething()
        {
            var list = new System.Collections.Generic.List<int>();
            var type = "System.Text";
        }
    }
}
"#;
        let refs = scanner
            .scan_references(content, "System.Collections.Generic", ScanScope::All)
            .unwrap();
        assert_eq!(refs.len(), 2);
    }

    #[tokio::test]
    async fn test_import_analyzer() {
        let plugin = CsharpPlugin::new();
        let analyzer = plugin.import_analyzer().unwrap();
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "using System;\nusing System.Text;").unwrap();

        let graph = analyzer.build_import_graph(temp_file.path()).unwrap();
        assert_eq!(graph.imports.len(), 2);
        assert!(graph.imports.iter().any(|i| i.module_path == "System"));
    }

    #[tokio::test]
    async fn test_manifest_updater() {
        let plugin = CsharpPlugin::new();
        let updater = plugin.manifest_updater().unwrap();
        let csproj_content = r#"
<Project Sdk="Microsoft.NET.Sdk">
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>
</Project>
"#;
        let mut temp_file = NamedTempFile::new().unwrap();
        write!(temp_file, "{}", csproj_content).unwrap();

        let updated_content = updater
            .update_dependency(
                temp_file.path(),
                "Newtonsoft.Json",
                "Newtonsoft.Json",
                Some("13.0.2"),
            )
            .await
            .unwrap();

        assert!(updated_content.contains("13.0.2"));
    }

    #[test]
    fn test_lsp_installer() {
        let plugin = CsharpPlugin::new();
        let installer = plugin.lsp_installer().unwrap();
        assert_eq!(installer.lsp_name(), "csharp-ls");
        // We can't easily test the installation itself, but we can check the name
    }

    #[test]
    fn test_analysis_metadata_test_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let patterns = plugin.test_patterns();

        // Should match NUnit test attribute
        let nunit_sample = "[Test]\npublic void MyTest() {}";
        assert!(patterns.iter().any(|p| p.is_match(nunit_sample)));

        // Should match xUnit fact attribute
        let xunit_sample = "[Fact]\npublic void MyFact() {}";
        assert!(patterns.iter().any(|p| p.is_match(xunit_sample)));

        // Should match MSTest attribute
        let mstest_sample = "[TestMethod]\npublic void MyMethod() {}";
        assert!(patterns.iter().any(|p| p.is_match(mstest_sample)));
    }

    #[test]
    fn test_analysis_metadata_assertion_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let patterns = plugin.assertion_patterns();

        // Should match Assert.Equal
        let assert_sample = "Assert.Equal(expected, actual);";
        assert!(patterns.iter().any(|p| p.is_match(assert_sample)));

        // Should match Assert.True
        let true_sample = "Assert.True(condition);";
        assert!(patterns.iter().any(|p| p.is_match(true_sample)));

        // Should match FluentAssertions
        let fluent_sample = "result.Should().Be(expected);";
        assert!(patterns.iter().any(|p| p.is_match(fluent_sample)));
    }

    #[test]
    fn test_analysis_metadata_complexity_keywords() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = CsharpPlugin::default();
        let keywords = plugin.complexity_keywords();

        // Should include C# control flow keywords
        assert!(keywords.contains(&"if"));
        assert!(keywords.contains(&"else"));
        assert!(keywords.contains(&"switch"));
        assert!(keywords.contains(&"case"));
        assert!(keywords.contains(&"for"));
        assert!(keywords.contains(&"foreach"));
        assert!(keywords.contains(&"while"));
        assert!(keywords.contains(&"catch"));
        assert!(keywords.contains(&"??"));

        // Check nesting penalty
        assert_eq!(plugin.nesting_penalty(), 1.3);
    }

    // ========================================================================
    // Edge case tests moved to mill-test-support/tests/edge_case_harness_integration.rs
    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = CsharpPlugin::new();

        // Skip test if .NET SDK is not available (check with small parse)
        let check_source = "class Test { public void Method() {} }";
        let check_result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(check_source).await });

        match check_result {
            Ok(parsed) if parsed.symbols.len() >= 2 => {
                // .NET available (found class + method)
            }
            _ => {
                eprintln!(
                    "Skipping test: .NET SDK not available (parser fallback only finds 2 symbols)"
                );
                return;
            }
        }

        // Create a large C# file (~100KB, 5000 methods)
        let mut large_source = String::from("using System.Collections.Generic;\n\nclass Large {\n");
        for i in 0..5000 {
            large_source.push_str(&format!(
                "    public int Method{}() {{ return {}; }}\n",
                i, i
            ));
        }
        large_source.push_str("}\n");

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert!(
            symbols.len() >= 5000,
            "Should find at least 5000 methods, found {}",
            symbols.len()
        );
        assert!(
            duration.as_secs() < 15,
            "Should parse within 15 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = CsharpPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("using System.Collections.Generic;\n\n");
        for _ in 0..10000 {
            content.push_str("System.Collections.Generic.List<int> list = new System.Collections.Generic.List<int>();\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "System.Collections.Generic", ScanScope::All)
            .expect("Should scan");
        let duration = start.elapsed();

        assert!(refs.len() >= 10001, "Should find using + qualified paths");
        // Large file scanning is acceptable at ~13s for 10,000+ references with complex regex
        assert!(
            duration.as_secs() < 15,
            "Should scan within 15 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // INTEGRATION TESTS (3 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_integration_project_creation() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = CsharpPlugin::new();

        // 1. Create .csproj file
        let csproj_content = r#"<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

</Project>
"#;

        harness
            .create_source_file("App.csproj", csproj_content)
            .expect("Failed to create App.csproj");

        // 2. Create C# source
        let source = r#"
using System;
using Newtonsoft.Json;

class Program
{
    public static int Add(int a, int b)
    {
        return a + b;
    }

    public static void Main()
    {
        Console.WriteLine("Hello, World!");
        var result = Add(5, 3);
        Console.WriteLine($"Sum: {result}");
    }
}
"#;

        harness
            .create_source_file("Program.cs", source)
            .expect("Failed to create Program.cs");

        // 3. Analyze project structure
        let parsed = plugin
            .parse(source)
            .await
            .expect("Failed to parse");

        // Parser may find symbols or use fallback mode
        // At minimum, we expect parsing to succeed
        let _symbols = parsed.symbols;

        // 4. Verify structure
        let csproj_path = harness.root().join("App.csproj");
        assert!(csproj_path.exists(), "Project file should exist");
    }

    #[tokio::test]
    async fn test_integration_namespace_refactoring() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = CsharpPlugin::new();

        // 1. Create files in namespace
        harness
            .create_directory("Models")
            .expect("Failed to create Models directory");

        let user_source = r#"
namespace MyApp.Models
{
    public class User
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
}
"#;

        harness
            .create_source_file("Models/User.cs", user_source)
            .expect("Failed to create User.cs");

        let program_source = r#"
using System;
using MyApp.Models;

class Program
{
    static void Main()
    {
        var user = new User { Name = "John", Age = 30 };
        Console.WriteLine($"{user.Name} is {user.Age}");
    }
}
"#;

        harness
            .create_source_file("Program.cs", program_source)
            .expect("Failed to create Program.cs");

        // 2. Parse and verify namespace structure
        let user_parsed = plugin
            .parse(user_source)
            .await
            .expect("Failed to parse User.cs");

        assert!(!user_parsed.symbols.is_empty(), "Should find User class");
        let has_user = user_parsed.symbols.iter().any(|s| s.name == "User");
        assert!(has_user, "Should find User class");

        // 3. Verify using statements
        let program_content = harness
            .read_file("Program.cs")
            .expect("Failed to read Program.cs");
        assert!(
            program_content.contains("using MyApp.Models"),
            "Should have using statement"
        );
    }

    #[tokio::test]
    async fn test_integration_dependency_management() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = CsharpPlugin::new();

        // 1. Create project with dependencies
        let csproj_content = r#"<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
    <PackageReference Include="Serilog" Version="3.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
  </ItemGroup>

</Project>
"#;

        let csproj_path = harness
            .create_source_file("App.csproj", csproj_content)
            .expect("Failed to create App.csproj");

        // 2. Analyze manifest for dependencies
        let manifest = plugin
            .analyze_manifest(&csproj_path)
            .await
            .expect("Failed to analyze csproj");

        // 3. Verify packages detected
        assert!(!manifest.dependencies.is_empty(), "Should find dependencies");
        let has_json = manifest
            .dependencies
            .iter()
            .any(|d| d.name.contains("Json") || d.name.contains("Newtonsoft"));
        let has_serilog = manifest
            .dependencies
            .iter()
            .any(|d| d.name.contains("Serilog"));
        assert!(
            has_json || has_serilog,
            "Should find at least one known package"
        );
    }
}
