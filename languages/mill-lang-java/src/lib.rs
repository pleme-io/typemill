//! Java language plugin for TypeMill
//!
//! Provides AST parsing, symbol extraction, and manifest analysis for Java.

pub mod import_support;
mod manifest;
mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{LanguagePlugin, ManifestData, ParsedSource, PluginResult, RefactoringProvider};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: JavaPlugin,
    name: "java",
    extensions: ["java"],
    manifest: "pom.xml",
    lsp_command: "jdtls",
    lsp_args: ["jdtls"],
    source_dir: "src/main/java",
    entry_point: "",
    module_separator: ".",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::JavaImportSupport,
        workspace_support: workspace_support::JavaWorkspaceSupport,
        project_factory: project_factory::JavaProjectFactory,
    },
    doc: "Java language plugin implementation providing comprehensive Java language support"
}

#[async_trait]
impl LanguagePlugin for JavaPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    impl_capability_delegations! {
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
    }
}

#[async_trait]
impl RefactoringProvider for JavaPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        let range = refactoring::CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col: 0,
        };
        refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plugin_creation() {
        let plugin = JavaPlugin::new();
        assert_eq!(plugin.metadata().name, "java");
    }

    #[test]
    fn test_file_extensions() {
        let plugin = JavaPlugin::new();
        assert!(plugin.handles_extension("java"));
    }

    #[test]
    fn test_java_capabilities() {
        let plugin = JavaPlugin::new();
        let caps = plugin.capabilities();

        assert!(caps.imports);
        assert!(caps.workspace);
        assert!(caps.project_factory);
    }

    #[test]
    fn test_java_import_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.import_parser().is_some());
    }

    #[test]
    fn test_java_workspace_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.workspace_support().is_some());
    }

    #[test]
    fn test_java_metadata() {
        let plugin = JavaPlugin::new();
        let metadata = plugin.metadata();

        assert_eq!(metadata.manifest_filename, "pom.xml");
        assert_eq!(metadata.entry_point, "");
        assert_eq!(metadata.module_separator, ".");
        assert_eq!(metadata.source_dir, "src/main/java");
    }
}