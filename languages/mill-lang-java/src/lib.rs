//! Java language plugin for TypeMill
//!
//! Provides AST parsing, symbol extraction, and manifest analysis for Java.

pub mod constants;
pub mod import_analyzer;
pub mod import_support;
pub mod lsp_installer;
mod manifest;
pub mod manifest_updater;
pub mod module_reference_scanner;
mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{LanguagePlugin, ManifestData, ParsedSource, PluginResult, RefactoringProvider};
use regex::Regex;
use std::path::Path;

use crate::constants::{assertion_patterns, test_patterns};

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: JavaPlugin,
    name: "java",
    extensions: ["java"],
    manifest: "pom.xml",
    lsp_command: "jdtls",
    lsp_args: ["jdtls"],
    source_dir: "src/main/java",
    entry_point: "",
    module_separator: ".",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::JavaImportSupport,
        workspace_support: workspace_support::JavaWorkspaceSupport,
        project_factory: project_factory::JavaProjectFactory,
        manifest_updater: manifest_updater::JavaManifestUpdater,
        module_reference_scanner: module_reference_scanner::JavaModuleReferenceScanner,
        import_analyzer: import_analyzer::JavaImportAnalyzer,
        lsp_installer: lsp_installer::JavaLspInstaller,
    },
    doc: "Java language plugin implementation providing comprehensive Java language support"
}

#[async_trait]
impl LanguagePlugin for JavaPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    impl_capability_delegations! {
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        manifest_updater => {
            manifest_updater: ManifestUpdater,
        },
        module_reference_scanner => {
            module_reference_scanner: ModuleReferenceScanner,
        },
        import_analyzer => {
            import_analyzer: ImportAnalyzer,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        },
    }
}

#[async_trait]
impl RefactoringProvider for JavaPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        let range = refactoring::CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col: 0,
        };
        refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginError::internal(e.to_string()))
    }
}

impl mill_plugin_api::AnalysisMetadata for JavaPlugin {
    fn test_patterns(&self) -> Vec<Regex> {
        test_patterns()
    }

    fn assertion_patterns(&self) -> Vec<Regex> {
        assertion_patterns()
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::JavaDoc
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec!["public", "private", "protected", "package-private"]
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["interface", "class", "enum", "record", "@interface"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec!["if", "else", "switch", "case", "for", "while", "catch", "&&", "||"]
    }

    fn nesting_penalty(&self) -> f32 {
        1.3
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::ScanScope;

    #[test]
    fn test_plugin_creation() {
        let plugin = JavaPlugin::new();
        assert_eq!(plugin.metadata().name, "java");
    }

    #[test]
    fn test_file_extensions() {
        let plugin = JavaPlugin::new();
        assert!(plugin.handles_extension("java"));
    }

    #[test]
    fn test_java_capabilities() {
        let plugin = JavaPlugin::new();
        let caps = plugin.capabilities();

        assert!(caps.imports);
        assert!(caps.workspace);
        assert!(caps.project_factory);
    }

    #[test]
    fn test_java_import_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.import_parser().is_some());
    }

    #[test]
    fn test_java_workspace_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.workspace_support().is_some());
    }

    #[test]
    fn test_java_metadata() {
        let plugin = JavaPlugin::new();
        let metadata = plugin.metadata();

        assert_eq!(metadata.manifest_filename, "pom.xml");
        assert_eq!(metadata.entry_point, "");
        assert_eq!(metadata.module_separator, ".");
        assert_eq!(metadata.source_dir, "src/main/java");
    }

    #[test]
    fn test_analysis_metadata_test_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let patterns = plugin.test_patterns();

        // Should match JUnit @Test annotation
        let test_sample = "@Test\npublic void testMethod() {}";
        assert!(patterns.iter().any(|p| p.is_match(test_sample)));

        // Should match JUnit 5 parameterized test
        let param_sample = "@ParameterizedTest\npublic void testWithParams() {}";
        assert!(patterns.iter().any(|p| p.is_match(param_sample)));

        // Should match JUnit 5 repeated test
        let repeated_sample = "@RepeatedTest(10)\npublic void testRepeated() {}";
        assert!(patterns.iter().any(|p| p.is_match(repeated_sample)));
    }

    #[test]
    fn test_analysis_metadata_assertion_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let patterns = plugin.assertion_patterns();

        // Should match Java assert keyword
        let assert_sample = "assert x == 5;";
        assert!(patterns.iter().any(|p| p.is_match(assert_sample)));

        // Should match JUnit assertEquals
        let junit_sample = "assertEquals(expected, actual);";
        assert!(patterns.iter().any(|p| p.is_match(junit_sample)));

        // Should match AssertJ/Hamcrest
        let assertj_sample = "assertThat(value).isEqualTo(expected);";
        assert!(patterns.iter().any(|p| p.is_match(assertj_sample)));
    }

    #[test]
    fn test_analysis_metadata_complexity_keywords() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let keywords = plugin.complexity_keywords();

        // Should include Java control flow keywords
        assert!(keywords.contains(&"if"));
        assert!(keywords.contains(&"else"));
        assert!(keywords.contains(&"switch"));
        assert!(keywords.contains(&"case"));
        assert!(keywords.contains(&"for"));
        assert!(keywords.contains(&"while"));
        assert!(keywords.contains(&"catch"));
        assert!(keywords.contains(&"&&"));
        assert!(keywords.contains(&"||"));

        // Check nesting penalty
        assert_eq!(plugin.nesting_penalty(), 1.3);
    }

    // ========================================================================
    // EDGE CASE TESTS (8 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_edge_parse_unicode_identifiers() {
        let plugin = JavaPlugin::new();
        let source = r#"
import java.util.List;
public class Main {
    public void тестфункция() {
        int مُتَغَيِّر = 42;
    }
}
"#;
        let result = plugin.parse(source).await;
        // Should not panic with Unicode identifiers
        assert!(result.is_ok() || result.is_err()); // Either way, no panic
    }

    #[tokio::test]
    async fn test_edge_parse_extremely_long_line() {
        let plugin = JavaPlugin::new();
        let long_string = "a".repeat(15000);
        let source = format!("public class Main {{ String x = \"{}\"; }}\n", long_string);
        let result = plugin.parse(&source).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_edge_parse_no_newlines() {
        let plugin = JavaPlugin::new();
        let source = "public class Main { public static void main(String[] args) { System.out.println(\"hello\"); } }";
        let result = plugin.parse(source).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_edge_scan_mixed_line_endings() {
        let plugin = JavaPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "import java.util.List;\r\nimport java.util.Map;\nimport java.io.File;";
        let refs = scanner.scan_references(content, "java.util", ScanScope::All).expect("Should scan");
        assert_eq!(refs.len(), 2);
    }

    #[tokio::test]
    async fn test_edge_parse_empty_file() {
        let plugin = JavaPlugin::new();
        let result = plugin.parse("").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[tokio::test]
    async fn test_edge_parse_whitespace_only() {
        let plugin = JavaPlugin::new();
        let result = plugin.parse("   \n\n\t\t\n   ").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[test]
    fn test_edge_scan_special_regex_chars() {
        let plugin = JavaPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "import java.util.List;";
        // Test with special regex characters
        let result = scanner.scan_references(content, "java.*", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    #[test]
    fn test_edge_handle_null_bytes() {
        let plugin = JavaPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");
        let content = "import java.util.List;\x00\nimport java.io.File;";
        let result = scanner.scan_references(content, "java.util", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = JavaPlugin::new();

        // Create a large Java file (~100KB, 5000 methods)
        let mut large_source = String::from("import java.util.List;\n\npublic class Large {\n");
        for i in 0..5000 {
            large_source.push_str(&format!("    public int method{}() {{ return {}; }}\n", i, i));
        }
        large_source.push_str("}\n");

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new().unwrap().block_on(async {
            plugin.parse(&large_source).await
        });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert!(symbols.len() >= 5000, "Should find at least 5000 methods");
        assert!(duration.as_secs() < 5, "Should parse within 5 seconds, took {:?}", duration);
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = JavaPlugin::new();
        let scanner = plugin.module_reference_scanner().expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("import java.util.List;\n\n");
        for _ in 0..10000 {
            content.push_str("java.util.List list = new java.util.ArrayList();\n");
        }

        let start = Instant::now();
        let refs = scanner.scan_references(&content, "java.util", ScanScope::All).expect("Should scan");
        let duration = start.elapsed();

        assert!(refs.len() >= 10001, "Should find import + qualified paths");
        assert!(duration.as_secs() < 10, "Should scan within 10 seconds, took {:?}", duration);
    }
}