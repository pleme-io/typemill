//! Java language plugin for TypeMill
//!
//! Provides comprehensive Java language support including:
//! - AST parsing using embedded Java parser (requires JVM runtime)
//! - Import management (import statements, package declarations)
//! - Refactoring operations (extract method/variable, inline variable)
//! - Workspace operations (Maven pom.xml-based projects)
//! - Maven manifest analysis and dependency management
//!
//! This plugin supports Java 11+ with Eclipse JDT Language Server (jdtls) as the LSP server.
//! The parser uses an embedded Java JAR that requires a Java runtime to be available.

pub mod constants;
pub mod import_analyzer;
pub mod import_support;
pub mod lsp_installer;
mod manifest;
pub mod manifest_updater;
pub mod module_reference_scanner;
mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    LanguagePlugin, ManifestData, ParsedSource, PluginResult, RefactoringProvider,
};
use regex::Regex;
use std::path::Path;

use crate::constants::{assertion_patterns, test_patterns};

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: JavaPlugin,
    name: "java",
    extensions: ["java"],
    manifest: "pom.xml",
    lsp_command: "jdtls",
    lsp_args: ["jdtls"],
    source_dir: "src/main/java",
    entry_point: "",
    module_separator: ".",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::JavaImportSupport,
        workspace_support: workspace_support::JavaWorkspaceSupport,
        project_factory: project_factory::JavaProjectFactory,
        manifest_updater: manifest_updater::JavaManifestUpdater,
        module_reference_scanner: module_reference_scanner::JavaModuleReferenceScanner,
        import_analyzer: import_analyzer::JavaImportAnalyzer,
        lsp_installer: lsp_installer::JavaLspInstaller,
    },
    doc: "Java language plugin implementation providing comprehensive Java language support"
}

#[async_trait]
impl LanguagePlugin for JavaPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        parser::parse_source(source)
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::analyze_manifest(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    impl_capability_delegations! {
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        manifest_updater => {
            manifest_updater: ManifestUpdater,
        },
        module_reference_scanner => {
            module_reference_scanner: ModuleReferenceScanner,
        },
        import_analyzer => {
            import_analyzer: ImportAnalyzer,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        },
    }
}

#[async_trait]
impl RefactoringProvider for JavaPlugin {
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        let range = refactoring::CodeRange {
            start_line,
            start_col: 0,
            end_line,
            end_col: 0,
        };
        refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }
}

impl mill_plugin_api::AnalysisMetadata for JavaPlugin {
    fn test_patterns(&self) -> Vec<Regex> {
        test_patterns()
    }

    fn assertion_patterns(&self) -> Vec<Regex> {
        assertion_patterns()
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::JavaDoc
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec!["public", "private", "protected", "package-private"]
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["interface", "class", "enum", "record", "@interface"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec![
            "if", "else", "switch", "case", "for", "while", "catch", "&&", "||",
        ]
    }

    fn nesting_penalty(&self) -> f32 {
        1.3
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::ScanScope;

    #[test]
    fn test_plugin_creation() {
        let plugin = JavaPlugin::new();
        assert_eq!(plugin.metadata().name, "java");
    }

    #[test]
    fn test_file_extensions() {
        let plugin = JavaPlugin::new();
        assert!(plugin.handles_extension("java"));
    }

    #[test]
    fn test_java_capabilities() {
        let plugin = JavaPlugin::new();
        let caps = plugin.capabilities();

        assert!(caps.imports);
        assert!(caps.workspace);
        assert!(caps.project_factory);
    }

    #[test]
    fn test_java_import_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.import_parser().is_some());
    }

    #[test]
    fn test_java_workspace_support() {
        let plugin = JavaPlugin::new();
        assert!(plugin.workspace_support().is_some());
    }

    #[test]
    fn test_java_metadata() {
        let plugin = JavaPlugin::new();
        let metadata = plugin.metadata();

        assert_eq!(metadata.manifest_filename, "pom.xml");
        assert_eq!(metadata.entry_point, "");
        assert_eq!(metadata.module_separator, ".");
        assert_eq!(metadata.source_dir, "src/main/java");
    }

    #[test]
    fn test_analysis_metadata_test_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let patterns = plugin.test_patterns();

        // Should match JUnit @Test annotation
        let test_sample = "@Test\npublic void testMethod() {}";
        assert!(patterns.iter().any(|p| p.is_match(test_sample)));

        // Should match JUnit 5 parameterized test
        let param_sample = "@ParameterizedTest\npublic void testWithParams() {}";
        assert!(patterns.iter().any(|p| p.is_match(param_sample)));

        // Should match JUnit 5 repeated test
        let repeated_sample = "@RepeatedTest(10)\npublic void testRepeated() {}";
        assert!(patterns.iter().any(|p| p.is_match(repeated_sample)));
    }

    #[test]
    fn test_analysis_metadata_assertion_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let patterns = plugin.assertion_patterns();

        // Should match Java assert keyword
        let assert_sample = "assert x == 5;";
        assert!(patterns.iter().any(|p| p.is_match(assert_sample)));

        // Should match JUnit assertEquals
        let junit_sample = "assertEquals(expected, actual);";
        assert!(patterns.iter().any(|p| p.is_match(junit_sample)));

        // Should match AssertJ/Hamcrest
        let assertj_sample = "assertThat(value).isEqualTo(expected);";
        assert!(patterns.iter().any(|p| p.is_match(assertj_sample)));
    }

    #[test]
    fn test_analysis_metadata_complexity_keywords() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = JavaPlugin::default();
        let keywords = plugin.complexity_keywords();

        // Should include Java control flow keywords
        assert!(keywords.contains(&"if"));
        assert!(keywords.contains(&"else"));
        assert!(keywords.contains(&"switch"));
        assert!(keywords.contains(&"case"));
        assert!(keywords.contains(&"for"));
        assert!(keywords.contains(&"while"));
        assert!(keywords.contains(&"catch"));
        assert!(keywords.contains(&"&&"));
        assert!(keywords.contains(&"||"));

        // Check nesting penalty
        assert_eq!(plugin.nesting_penalty(), 1.3);
    }

    // ========================================================================
    // Edge case tests moved to mill-test-support/tests/edge_case_harness_integration.rs
    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    /// Helper to ensure Java parser JAR is built before running integration tests
    fn require_java_parser_jar() {
        #[cfg(not(java_parser_jar_exists))]
        panic!(
            "\n╔══════════════════════════════════════════════════════════════════╗\n\
             ║ Java parser JAR not found!                                       ║\n\
             ║                                                                  ║\n\
             ║ To run this test, build the JAR:                                ║\n\
             ║   cd languages/mill-lang-java/resources/java-parser             ║\n\
             ║   mvn package                                                    ║\n\
             ║                                                                  ║\n\
             ║ Then rebuild:                                                    ║\n\
             ║   cargo clean -p mill-lang-java                                 ║\n\
             ║   cargo test -p mill-lang-java                                  ║\n\
             ╚══════════════════════════════════════════════════════════════════╝\n"
        );
    }

    #[test]
    fn test_performance_parse_large_file() {
        require_java_parser_jar();

        use std::time::Instant;
        let plugin = JavaPlugin::new();

        // Create a large Java file (~100KB, 5000 methods)
        let mut large_source = String::from("import java.util.List;\n\npublic class Large {\n");
        for i in 0..5000 {
            large_source.push_str(&format!(
                "    public int method{}() {{ return {}; }}\n",
                i, i
            ));
        }
        large_source.push_str("}\n");

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert!(symbols.len() >= 5000, "Should find at least 5000 methods");
        assert!(
            duration.as_secs() < 5,
            "Should parse within 5 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = JavaPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("import java.util.List;\n\n");
        for _ in 0..10000 {
            content.push_str("java.util.List list = new java.util.ArrayList();\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "java.util", ScanScope::All)
            .expect("Should scan");
        let duration = start.elapsed();

        assert!(refs.len() >= 10001, "Should find import + qualified paths");
        assert!(
            duration.as_secs() < 10,
            "Should scan within 10 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // EDGE CASE TESTS (2 additional)
    // ========================================================================

    #[test]
    fn test_edge_unicode_in_strings() {
        let plugin = JavaPlugin::new();
        let source = r#"
public class Main {
    public static void main(String[] args) {
        String unicode = "日本語のテキスト";
        System.out.println(unicode);
    }
}
"#;
        // Should handle Unicode in string literals without panicking
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });
        assert!(result.is_ok() || result.is_err()); // Either way, no panic
    }

    #[test]
    fn test_edge_extremely_long_method() {
        let plugin = JavaPlugin::new();
        let mut source = String::from("public class Main {\n    public void method(");
        for i in 0..1000 {
            source.push_str(&format!("int param{}, ", i));
        }
        source.push_str("int finalParam) {}\n}");

        // Should handle very long method signatures
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&source).await });
        assert!(result.is_ok() || result.is_err()); // Either way, no panic
    }

    // ========================================================================
    // INTEGRATION TEST (1 additional)
    // ========================================================================

    #[tokio::test]
    async fn test_integration_maven_project_structure() {
        let harness = mill_test_support::harness::IntegrationTestHarness::new()
            .expect("Should create harness");

        // Create Maven pom.xml
        harness
            .create_source_file(
                "pom.xml",
                r#"<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>my-app</artifactId>
  <version>1.0.0</version>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.13.2</version>
    </dependency>
  </dependencies>
</project>"#,
            )
            .expect("Should create pom.xml");

        // Create Java source
        harness
            .create_source_file(
                "src/main/java/App.java",
                r#"package com.example;

public class App {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}"#,
            )
            .expect("Should create App.java");

        // Verify structure
        let pom_content = harness
            .read_file("pom.xml")
            .expect("Should read pom.xml");
        assert!(pom_content.contains("project"));
        assert!(pom_content.contains("modelVersion"));
        assert!(pom_content.contains("dependencies"));

        let java_content = harness
            .read_file("src/main/java/App.java")
            .expect("Should read App.java");
        assert!(java_content.contains("package"));
        assert!(java_content.contains("public class"));
    }
}
