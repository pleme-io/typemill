//! Python Language Plugin for TypeMill
//!
//! Complete Python language support implementing the `LanguagePlugin` trait.
//!
//! # Features
//!
//! - Dual-mode AST parsing (native Python parser + regex fallback)
//! - Import analysis (import, from...import)
//! - Symbol extraction (functions, classes, methods, variables)
//! - Manifest support (requirements.txt, pyproject.toml, setup.py, Pipfile)
//! - Refactoring operations (extract function, inline variable, extract variable)

pub mod constants;
pub mod import_support;
pub mod lsp_installer;
pub mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod reference_detector;
mod string_literal_support;
pub mod test_fixtures;
pub mod workspace_support;

#[cfg(test)]
mod performance_tests;
#[cfg(test)]
mod benchmark_manifest;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    FileDiscovery, LanguagePlugin, ManifestData, ParsedSource, PluginResult, StandardFileDiscovery,
};
use std::path::Path;
use tracing::{debug, warn};

#[derive(Default)]
pub struct PythonFileDiscovery;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: PythonPlugin,
    name: "python",
    extensions: ["py"],
    manifest: "pyproject.toml",
    lsp_command: "pylsp",
    lsp_args: ["pylsp"],
    source_dir: ".",
    entry_point: "__init__.py",
    module_separator: ".",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::PythonImportSupport,
        workspace_support: workspace_support::PythonWorkspaceSupport,
        project_factory: project_factory::PythonProjectFactory,
        lsp_installer: lsp_installer::PythonLspInstaller,
        reference_detector: reference_detector::PythonReferenceDetector,
        file_discovery: PythonFileDiscovery,
    },
    doc: "Python language plugin implementation providing comprehensive Python language support"
}

#[async_trait]
impl FileDiscovery for PythonFileDiscovery {
    async fn find_source_files(&self, root_path: &Path) -> PluginResult<Vec<std::path::PathBuf>> {
        let discovery = StandardFileDiscovery::new(PythonPlugin::METADATA.extensions);
        discovery.find_source_files(root_path).await
    }
}

#[async_trait]
impl LanguagePlugin for PythonPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        debug!("Parsing Python source code");

        let source = source.to_string();

        tokio::task::spawn_blocking(move || {
            // Extract all symbols from the source code
            let symbols = parser::extract_symbols(&source)?;

            // Parse imports
            let imports = parser::parse_python_imports(&source)?;

            // Create a simplified AST representation
            let functions = parser::extract_python_functions(&source)?;
            let variables = parser::extract_python_variables(&source)?;

            let ast_json = serde_json::json!({
                "type": "Module",
                "functions_count": functions.len(),
                "variables_count": variables.len(),
                "imports_count": imports.len(),
                "imports": imports,
            });

            debug!(
                symbols_count = symbols.len(),
                functions_count = functions.len(),
                imports_count = imports.len(),
                "Parsed Python source"
            );

            Ok(ParsedSource {
                data: ast_json,
                symbols,
            })
        })
        .await
        .map_err(|e| mill_plugin_api::PluginApiError::internal(format!("Task join error: {}", e)))?
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        let filename = path.file_name().and_then(|s| s.to_str()).ok_or_else(|| {
            mill_plugin_api::PluginApiError::invalid_input("Invalid manifest path")
        })?;

        debug!(filename = %filename, path = ?path, "Analyzing Python manifest");

        match filename {
            "requirements.txt" => manifest::parse_requirements_txt(path).await,
            "pyproject.toml" => manifest::parse_pyproject_toml(path).await,
            "setup.py" => manifest::parse_setup_py(path).await,
            "Pipfile" => manifest::parse_pipfile(path).await,
            _ => Err(mill_plugin_api::PluginApiError::not_supported(format!(
                "Unsupported Python manifest file: {}",
                filename
            ))),
        }
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        debug!("Listing Python functions");

        // Try native Python parser first
        match parser::list_functions(source).await {
            Ok(functions) => {
                debug!(
                    functions_count = functions.len(),
                    method = "native_parser",
                    "Listed functions"
                );
                Ok(functions)
            }
            Err(e) => {
                warn!(
                    error = %e,
                    "Native Python parser failed, falling back to regex"
                );
                // Fallback to regex-based extraction
                let functions = parser::extract_python_functions(source)?;
                Ok(functions.into_iter().map(|f| f.name).collect())
            }
        }
    }

    fn analyze_detailed_imports(
        &self,
        source: &str,
        file_path: Option<&Path>,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        parser::analyze_imports(source, file_path)
    }

    fn test_fixtures(&self) -> Option<mill_plugin_api::LanguageTestFixtures> {
        Some(test_fixtures::python_test_fixtures())
    }

    fn rewrite_file_references(
        &self,
        content: &str,
        old_path: &Path,
        new_path: &Path,
        _current_file: &Path,
        _project_root: &Path,
        _rename_info: Option<&serde_json::Value>,
    ) -> Option<(String, usize)> {
        use mill_plugin_api::ImportMoveSupport;

        // First, rewrite imports using move support
        let (content_after_imports, import_count) = self
            .import_support
            .rewrite_imports_for_move(content, old_path, new_path);

        // Then, rewrite string literals (path-like strings)
        let (final_content, literal_count) = string_literal_support::rewrite_string_literals(
            &content_after_imports,
            old_path,
            new_path,
        )
        .ok()?;

        let total_changes = import_count + literal_count;

        if total_changes > 0 {
            Some((final_content, total_changes))
        } else {
            None
        }
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            module_reference_scanner: ModuleReferenceScanner,
            refactoring_provider: RefactoringProvider,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        },
        file_discovery => {
            file_discovery: FileDiscovery,
        },
        reference_detector => {
            reference_detector: ReferenceDetector,
        },
    }
}

#[async_trait]
impl mill_plugin_api::ManifestUpdater for PythonPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> mill_plugin_api::PluginResult<String> {
        // For Python, handle both renaming and version updates
        if old_name == new_name {
            // Version-only update
            if let Some(version) = new_version {
                manifest::update_dependency_in_pyproject(
                    manifest_path,
                    new_name,
                    version,
                    None, // Use default "dependencies" section
                )
                .map_err(mill_plugin_api::PluginApiError::internal)
            } else {
                // No version provided, return unchanged
                std::fs::read_to_string(manifest_path).map_err(|e| {
                    mill_plugin_api::PluginApiError::internal(format!(
                        "Failed to read manifest: {}",
                        e
                    ))
                })
            }
        } else {
            // Rename dependency - use the existing update_pyproject_toml function
            manifest::update_pyproject_toml(manifest_path, old_name, new_name, new_version).await
        }
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        manifest::generate_pyproject_toml(package_name, dependencies)
    }
}
// ============================================================================
// Capability Trait Implementations
// ============================================================================

#[async_trait]
impl mill_plugin_api::RefactoringProvider for PythonPlugin {
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        function_name: &str,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        // Construct a CodeRange from start_line and end_line
        let range = refactoring::CodeRange {
            start_line,
            start_col,
            end_line,
            end_col,
        };

        refactoring::plan_extract_function(source, &range, function_name, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
        .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }

    fn supports_extract_constant(&self) -> bool {
        true
    }

    async fn plan_extract_constant(
        &self,
        source: &str,
        line: u32,
        character: u32,
        constant_name: &str,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_constant(source, line, character, constant_name, file_path)
            .map_err(|e| mill_plugin_api::PluginApiError::internal(e.to_string()))
    }
}

impl mill_plugin_api::ImportAnalyzer for PythonPlugin {
    fn build_import_graph(
        &self,
        file_path: &Path,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::ImportGraph> {
        // Read the file content
        let content = std::fs::read_to_string(file_path).map_err(|e| {
            mill_plugin_api::PluginApiError::internal(format!("Failed to read file: {}", e))
        })?;

        // Use the existing parser::analyze_imports method
        parser::analyze_imports(&content, Some(file_path))
    }
}

impl mill_plugin_api::ModuleReferenceScanner for PythonPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> mill_plugin_api::PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        use mill_plugin_api::{ModuleReference, ReferenceKind, ScanScope};

        let mut references = Vec::new();

        for (line_idx, line) in content.lines().enumerate() {
            let line_num = line_idx + 1;

            // Find import statements: "import module" or "from module import"
            if scope != ScanScope::QualifiedPaths {
                if let Some(col) = line.find(&format!("import {}", module_name)) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: col,
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::Declaration,
                    });
                }
                if let Some(col) = line.find(&format!("from {}", module_name)) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: col + 5, // After "from "
                        length: module_name.len(),
                        text: module_name.to_string(),
                        kind: ReferenceKind::Declaration,
                    });
                }
            }

            // Find qualified paths: "module.function()"
            if scope == ScanScope::QualifiedPaths || scope == ScanScope::All {
                let pattern = format!("{}.", module_name);
                for (idx, _) in line.match_indices(&pattern) {
                    // Skip if this is inside a string
                    let before = &line[..idx];
                    let in_string = before.matches('"').count() % 2 == 1
                        || before.matches('\'').count() % 2 == 1;

                    if !in_string {
                        references.push(ModuleReference {
                            line: line_num,
                            column: idx,
                            length: module_name.len(),
                            text: module_name.to_string(),
                            kind: ReferenceKind::QualifiedPath,
                        });
                    }
                }
            }

            // Find string literals containing module path
            if scope == ScanScope::All {
                // Look for strings like "module/file.py" or "module.py"
                for quote in ['"', '\''] {
                    if let Some(start) = line.find(quote) {
                        if let Some(end) = line[start + 1..].find(quote) {
                            let string_content = &line[start + 1..start + 1 + end];
                            if string_content.contains(module_name) {
                                if let Some(idx) = string_content.find(module_name) {
                                    references.push(ModuleReference {
                                        line: line_num,
                                        column: start + 1 + idx,
                                        length: module_name.len(),
                                        text: module_name.to_string(),
                                        kind: ReferenceKind::StringLiteral,
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        Ok(references)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::ScanScope;

    #[tokio::test]
    async fn test_python_plugin_basic() {
        let plugin = PythonPlugin::new();
        assert_eq!(plugin.metadata().name, "python");
        assert_eq!(plugin.metadata().extensions, &["py"]);
        assert!(plugin.handles_extension("py"));
        assert!(!plugin.handles_extension("rs"));
    }

    #[tokio::test]
    async fn test_python_plugin_handles_manifests() {
        let plugin = PythonPlugin::new();

        assert!(plugin.handles_manifest("pyproject.toml"));
        assert!(!plugin.handles_manifest("Cargo.toml"));
    }

    #[tokio::test]
    async fn test_python_plugin_parse() {
        let plugin = PythonPlugin::new();

        let source = r#"
import os
from pathlib import Path

CONSTANT = 42

def hello():
    print('Hello, world!')

class MyClass:
    pass
"#;

        let result = plugin.parse(source).await;
        assert!(result.is_ok());

        let parsed = result.unwrap();
        assert!(!parsed.symbols.is_empty());

        // Should have function, class, and constant symbols
        let has_function = parsed
            .symbols
            .iter()
            .any(|s| s.name == "hello" && s.kind == mill_plugin_api::SymbolKind::Function);
        let has_class = parsed
            .symbols
            .iter()
            .any(|s| s.name == "MyClass" && s.kind == mill_plugin_api::SymbolKind::Class);
        let has_constant = parsed
            .symbols
            .iter()
            .any(|s| s.name == "CONSTANT" && s.kind == mill_plugin_api::SymbolKind::Constant);

        assert!(has_function, "Should parse function");
        assert!(has_class, "Should parse class");
        assert!(has_constant, "Should parse constant");
    }

    #[tokio::test]
    async fn test_python_plugin_list_functions() {
        let plugin = PythonPlugin::new();

        let source = r#"
def function_one():
    pass

def function_two(param):
    return param * 2

class MyClass:
    def method_one(self):
        pass
"#;

        let result = plugin.list_functions(source).await;
        // This may fail if python3 is not available, which is okay for the test
        // The fallback will still work
        if let Ok(functions) = result {
            assert!(functions.contains(&"function_one".to_string()));
            assert!(functions.contains(&"function_two".to_string()));
        }
    }

    #[test]
    fn test_python_module_constants() {
        let plugin = PythonPlugin::new();

        assert_eq!(plugin.metadata().manifest_filename, "pyproject.toml");
        assert_eq!(plugin.metadata().entry_point, "__init__.py");
        assert_eq!(plugin.metadata().module_separator, ".");
        assert_eq!(plugin.metadata().source_dir, ".");
    }

    #[test]
    fn test_python_capabilities() {
        let plugin = PythonPlugin::new();
        let caps = plugin.capabilities();

        assert!(caps.imports, "Python plugin should support imports");
        assert!(caps.workspace, "Python plugin should support workspace");
    }

    #[test]
    fn test_python_workspace_support() {
        let plugin = PythonPlugin::new();
        assert!(
            plugin.workspace_support().is_some(),
            "Python should have workspace support"
        );
    }

    // ========================================================================
    // Edge case tests moved to mill-test-support/tests/edge_case_harness_integration.rs
    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = PythonPlugin::new();

        // Create a large Python file (~100KB, 5000 functions)
        let mut large_source = String::from("import os\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!("def function{}():\n    return {}\n\n", i, i));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert_eq!(symbols.len(), 5000, "Should find all 5000 functions");
        assert!(
            duration.as_secs() < 5,
            "Should parse within 5 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = PythonPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("import os\n\n");
        for _ in 0..10000 {
            content.push_str("os.path.exists('test.txt')\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "os", ScanScope::All)
            .expect("Should scan");
        let duration = start.elapsed();

        assert_eq!(
            refs.len(),
            10001,
            "Should find import + 10K qualified paths"
        );
        assert!(
            duration.as_secs() < 10,
            "Should scan within 10 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // INTEGRATION TESTS (3 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_integration_create_parse_refactor() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = PythonPlugin::new();

        // 1. Create Python source file
        let source = r#"
def add(x, y):
    """Add two numbers."""
    return x + y

def multiply(x, y):
    """Multiply two numbers."""
    return x * y

def main():
    result1 = add(5, 3)
    result2 = multiply(4, 2)
    print(f"Add: {result1}, Multiply: {result2}")
"#;

        let _file_path = harness
            .create_source_file("test.py", source)
            .expect("Failed to create file");

        // 2. Parse and extract symbols
        let parsed = plugin.parse(source).await.expect("Failed to parse");

        assert!(!parsed.symbols.is_empty(), "Should find symbols");
        let has_add = parsed.symbols.iter().any(|s| s.name == "add");
        let has_multiply = parsed.symbols.iter().any(|s| s.name == "multiply");
        assert!(has_add, "Should find add function");
        assert!(has_multiply, "Should find multiply function");

        // 3. Verify refactoring capability
        let functions = plugin
            .list_functions(source)
            .await
            .expect("Failed to list functions");
        assert!(functions.contains(&"add".to_string()));
        assert!(functions.contains(&"multiply".to_string()));
    }

    #[tokio::test]
    async fn test_integration_import_dependency_workflow() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = PythonPlugin::new();

        // 1. Create package with requirements.txt
        let _req_file = harness
            .create_source_file("requirements.txt", "requests==2.28.0\nclick>=8.0.0\n")
            .expect("Failed to create requirements.txt");

        // 2. Create Python file with imports
        let source = r#"
import requests
from click import command, option

@command()
@option('--name', default='World')
def hello(name):
    """Greet someone."""
    response = requests.get('https://api.example.com/greet')
    print(f'Hello {name}!')
"#;

        let _py_file = harness
            .create_source_file("main.py", source)
            .expect("Failed to create main.py");

        // 3. Analyze imports
        let parsed = plugin.parse(source).await.expect("Failed to parse");

        assert!(
            !parsed.symbols.is_empty(),
            "Should parse imports and symbols"
        );

        // 4. Verify import analysis
        let imports = plugin
            .analyze_detailed_imports(source, None)
            .expect("Failed to analyze imports");

        assert!(!imports.imports.is_empty(), "Should find imports");
        let has_requests = imports
            .imports
            .iter()
            .any(|imp| imp.module_path.contains("requests"));
        let has_click = imports
            .imports
            .iter()
            .any(|imp| imp.module_path.contains("click"));
        assert!(has_requests, "Should find requests import");
        assert!(has_click, "Should find click import");
    }

    #[tokio::test]
    async fn test_integration_module_structure_analysis() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = PythonPlugin::new();

        // 1. Create module structure
        harness
            .create_directory("mypackage")
            .expect("Failed to create directory");

        let init_source = r#"
"""Initialize mypackage."""
from .utils import helper_function
from .models import User, Post

__all__ = ['helper_function', 'User', 'Post']
"#;

        harness
            .create_source_file("mypackage/__init__.py", init_source)
            .expect("Failed to create __init__.py");

        let utils_source = r#"
def helper_function(x):
    """Help with something."""
    return x * 2

class HelperClass:
    """A helper class."""
    pass
"#;

        harness
            .create_source_file("mypackage/utils.py", utils_source)
            .expect("Failed to create utils.py");

        // 2. Parse module structure
        let init_parsed = plugin
            .parse(init_source)
            .await
            .expect("Failed to parse __init__.py");

        assert!(
            !init_parsed.symbols.is_empty(),
            "Should find symbols in __init__"
        );

        let utils_parsed = plugin
            .parse(utils_source)
            .await
            .expect("Failed to parse utils.py");

        assert!(
            !utils_parsed.symbols.is_empty(),
            "Should find symbols in utils"
        );

        // Verify specific symbols
        let has_helper_func = utils_parsed
            .symbols
            .iter()
            .any(|s| s.name == "helper_function");
        let has_helper_class = utils_parsed.symbols.iter().any(|s| s.name == "HelperClass");
        assert!(has_helper_func, "Should find helper_function");
        assert!(has_helper_class, "Should find HelperClass");

        // 3. Test manifest analysis
        let manifest_source = r#"[build-system]
requires = ["setuptools>=45", "wheel"]

[project]
name = "mypackage"
version = "1.0.0"
description = "My awesome package"
dependencies = [
    "requests>=2.0.0",
]
"#;

        let manifest_file = harness
            .create_source_file("pyproject.toml", manifest_source)
            .expect("Failed to create pyproject.toml");

        let manifest = plugin
            .analyze_manifest(&manifest_file)
            .await
            .expect("Failed to analyze manifest");

        assert!(
            !manifest.dependencies.is_empty(),
            "Should find dependencies"
        );
    }

    #[tokio::test(flavor = "current_thread")]
    async fn test_list_functions_is_non_blocking() {
        // This test verifies that list_functions does not block the async executor
        let plugin = PythonPlugin::new();
        // 50,000 lines should take some time to parse/transfer
        let source = "def foo(): pass\n".repeat(50000);

        // Spawn a background task that attempts to tick while list_functions is running
        let start_time = std::time::Instant::now();
        // We want the background task to run within the next 500ms.
        // If list_functions blocks for > 500ms, the background task will not get a chance to run
        // before the deadline expires.
        let end_time = start_time + std::time::Duration::from_millis(500);

        let background_handle = tokio::spawn(async move {
            let mut ticks = 0;
            while std::time::Instant::now() < end_time {
                tokio::time::sleep(std::time::Duration::from_millis(10)).await;
                ticks += 1;
            }
            ticks
        });

        // Run list_functions
        let result = plugin.list_functions(&source).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().len(), 50000);

        let ticks = background_handle.await.unwrap();

        // If it was blocking (and took > 500ms), ticks would be 0.
        // We expect some concurrency.
        // Note: this assertion might be flaky on extremely slow machines if list_functions finishes < 10ms,
        // but with 50,000 lines it should take significantly longer than 10ms.
        assert!(ticks > 0, "list_functions blocked the executor! Ticks: {}", ticks);
    }
}
