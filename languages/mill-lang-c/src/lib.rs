//! C language plugin for TypeMill
//!
//! Provides comprehensive C language support including:
//! - AST parsing using tree-sitter
//! - Import/include management (#include directives)
//! - Refactoring operations (extract function/variable/constant, inline variable)
//! - Workspace operations (Makefile-based projects)
//! - CMake and Makefile manifest analysis
//!
//! This plugin supports C99 and C11 standards with `clangd` as the LSP server.

mod ast_parser;
mod cmake_parser;
pub mod constants;
mod import_support;
mod lsp_installer;
mod makefile_parser;
mod project_factory;
mod refactoring;
mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater, ModuleReference,
    ModuleReferenceScanner, ParsedSource, PluginResult, ReferenceKind, ScanScope,
};
use std::path::Path;

use mill_foundation::protocol::{ImportGraph, ImportInfo, ImportType};

use crate::constants::{INCLUDE_PATTERN, LIBS_PATTERN};

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: CPlugin,
    name: "c",
    extensions: ["c", "h"],
    manifest: "Makefile",
    lsp_command: "clangd",
    lsp_args: [""],
    source_dir: "src",
    entry_point: "main.c",
    module_separator: "::",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::CImportSupport,
        project_factory: project_factory::CProjectFactory,
        workspace_support: workspace_support::CWorkspaceSupport,
        lsp_installer: lsp_installer::CLspInstaller,
    },
    doc: "C language plugin implementation providing comprehensive C language support"
}

#[async_trait]
impl LanguagePlugin for CPlugin {
    impl_language_plugin_basics!();

    /// Parse C source code into an AST representation
    ///
    /// Uses tree-sitter to parse C source and extract symbols (functions, structs, etc.)
    ///
    /// # Arguments
    ///
    /// * `source` - The C source code to parse
    ///
    /// # Returns
    ///
    /// A `ParsedSource` containing extracted symbols with location information
    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        Ok(ast_parser::parse_source(source))
    }

    /// List all function names in C source code
    ///
    /// Extracts function declarations and definitions using tree-sitter AST traversal
    ///
    /// # Arguments
    ///
    /// * `source` - The C source code to analyze
    ///
    /// # Returns
    ///
    /// A vector of function names found in the source
    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        Ok(ast_parser::list_functions(source))
    }

    /// Analyze C project manifest files (Makefile or CMakeLists.txt)
    ///
    /// Parses either CMake or Make-based build configurations to extract
    /// dependencies, targets, and project structure
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the manifest file (Makefile or CMakeLists.txt)
    ///
    /// # Returns
    ///
    /// Structured manifest data containing dependencies and configuration
    ///
    /// # Errors
    ///
    /// Returns an error if the file type is not supported
    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        let filename = path
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or_default();
        if filename.starts_with("CMakeLists") {
            cmake_parser::analyze_cmake_manifest(path)
        } else if filename == "Makefile" {
            makefile_parser::analyze_makefile_manifest(path)
        } else {
            Err(mill_plugin_api::PluginApiError::not_supported(
                "Manifest analysis for this file type",
            ))
        }
    }

    /// Analyze detailed imports from C source code, returning full ImportGraph
    ///
    /// Provides enhanced import analysis with full metadata including:
    /// - System headers vs local headers
    /// - Source locations for each import
    /// - External dependencies tracking
    ///
    /// # Arguments
    ///
    /// * `source` - The C source code to analyze
    /// * `file_path` - Optional path to the source file for context
    ///
    /// # Returns
    ///
    /// A complete `ImportGraph` with detailed import information
    fn analyze_detailed_imports(
        &self,
        source: &str,
        file_path: Option<&Path>,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        self.import_support
            .analyze_detailed_imports(source, file_path)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl ManifestUpdater for CPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        _old_name: &str,
        new_name: &str,
        _new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = std::fs::read_to_string(manifest_path).unwrap();
        if let Some(caps) = LIBS_PATTERN.captures(&content) {
            let existing_libs = caps.get(1).unwrap().as_str();
            let new_libs = format!("{} -l{}", existing_libs, new_name);
            Ok(content.replace(existing_libs, &new_libs))
        } else {
            Ok(format!("{}\nLIBS = -l{}", content, new_name))
        }
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        let libs = dependencies
            .iter()
            .map(|d| format!("-l{}", d))
            .collect::<Vec<String>>()
            .join(" ");

        format!(
            "CC = gcc\nCFLAGS = -Wall -Wextra -std=c11\nTARGET = {}\nSRCS = src/main.c\nLIBS = {}\n\nall: $(TARGET)\n\n$(TARGET): $(SRCS)\n\t$(CC) $(CFLAGS) -o $(TARGET) $(SRCS) $(LIBS)\n\nclean:\n\trm -f $(TARGET)\n",
            package_name, libs
        )
    }
}

impl ImportAnalyzer for CPlugin {
    fn build_import_graph(&self, file_path: &Path) -> PluginResult<ImportGraph> {
        let content = std::fs::read_to_string(file_path).unwrap();
        let mut imports = Vec::new();

        for (i, line) in content.lines().enumerate() {
            for cap in INCLUDE_PATTERN.captures_iter(line) {
                imports.push(ImportInfo {
                    module_path: cap.get(2).unwrap().as_str().to_string(),
                    import_type: ImportType::CInclude,
                    named_imports: vec![],
                    default_import: None,
                    namespace_import: None,
                    type_only: false,
                    location: mill_foundation::protocol::SourceLocation {
                        start_line: i as u32,
                        start_column: cap.get(2).unwrap().start() as u32,
                        end_line: i as u32,
                        end_column: cap.get(2).unwrap().end() as u32,
                    },
                });
            }
        }

        use chrono::Utc;
        Ok(ImportGraph {
            source_file: file_path.to_str().unwrap().to_string(),
            imports,
            importers: vec![],
            metadata: mill_foundation::protocol::ImportGraphMetadata {
                language: "c".to_string(),
                parsed_at: Utc::now(),
                parser_version: "0.1.0".to_string(),
                circular_dependencies: vec![],
                external_dependencies: vec![],
            },
        })
    }
}

impl ModuleReferenceScanner for CPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: ScanScope,
    ) -> PluginResult<Vec<ModuleReference>> {
        let mut references = Vec::new();

        for (i, line) in content.lines().enumerate() {
            if scope == ScanScope::AllUseStatements
                && (line.trim().starts_with("//") || line.trim().starts_with("/*"))
            {
                continue;
            }

            for cap in INCLUDE_PATTERN.captures_iter(line) {
                let header_name = cap.get(2).unwrap().as_str();

                // Filter by module_name if provided
                if module_name.is_empty() || header_name.contains(module_name) {
                    references.push(ModuleReference {
                        text: header_name.to_string(),
                        line: i + 1,
                        column: cap.get(2).unwrap().start(),
                        length: header_name.len(),
                        kind: ReferenceKind::Declaration,
                    });
                }
            }
        }

        Ok(references)
    }
}

// Implement RefactoringProvider trait for CPlugin
#[async_trait]
impl mill_plugin_api::RefactoringProvider for CPlugin {
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
    }

    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_function(source, start_line, end_line, function_name, file_path)
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
    }

    fn supports_extract_constant(&self) -> bool {
        true
    }

    async fn plan_extract_constant(
        &self,
        source: &str,
        line: u32,
        character: u32,
        name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_constant(source, line, character, name, file_path)
    }
}

#[cfg(test)]
mod tests;

#[cfg(test)]
mod inline_tests {
    use super::*;
    use mill_test_support::harness::{edge_cases, *};
    use std::time::Instant;

    // ========================================================================
    // BASIC PLUGIN TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_c_plugin_basic_metadata() {
        let plugin = CPlugin::new();
        assert_eq!(plugin.metadata().name, "c");
        assert_eq!(plugin.metadata().extensions, &["c", "h"]);
        assert!(plugin.handles_extension("c"));
        assert!(plugin.handles_extension("h"));
        assert!(!plugin.handles_extension("rs"));
    }

    #[test]
    fn test_c_plugin_manifest_support() {
        let plugin = CPlugin::new();
        assert!(plugin.handles_manifest("Makefile"));
        // Note: handles_manifest checks for "Makefile" by default,
        // CMakeLists.txt is handled in analyze_manifest method
        assert!(!plugin.handles_manifest("Cargo.toml"));
        assert!(!plugin.handles_manifest("package.json"));
    }

    // ========================================================================
    // PARSE TESTS (4 tests)
    // ========================================================================

    #[test]
    fn test_parse_valid_c_code() {
        let plugin = CPlugin::new();
        let source = r#"
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 3);
    printf("Result: %d\n", result);
    return 0;
}
"#;
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });

        assert!(result.is_ok(), "Should parse valid C code");
        let parsed = result.unwrap();
        assert!(!parsed.symbols.is_empty(), "Should extract symbols");

        // Verify function symbols were found
        let has_add = parsed.symbols.iter().any(|s| s.name == "add");
        let has_main = parsed.symbols.iter().any(|s| s.name == "main");
        assert!(has_add, "Should find add function");
        assert!(has_main, "Should find main function");
    }

    #[test]
    fn test_parse_invalid_syntax() {
        let plugin = CPlugin::new();
        let source = "int main( { return 0; }"; // Missing closing paren

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });

        // Plugin should handle gracefully - either succeed with partial parsing
        // or return error, but not panic
        assert!(result.is_ok() || result.is_err());
    }

    #[test]
    fn test_parse_empty_file() {
        let plugin = CPlugin::new();
        let source = edge_cases::empty_file();

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });

        assert!(result.is_ok(), "Should handle empty file gracefully");
        let parsed = result.unwrap();
        // Empty file should have no symbols
        assert_eq!(parsed.symbols.len(), 0, "Empty file should have no symbols");
    }

    #[test]
    fn test_parse_whitespace_only_file() {
        let plugin = CPlugin::new();
        let source = edge_cases::whitespace_only();

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });

        assert!(result.is_ok(), "Should handle whitespace-only file");
        let parsed = result.unwrap();
        assert_eq!(
            parsed.symbols.len(),
            0,
            "Whitespace-only file should have no symbols"
        );
    }

    // ========================================================================
    // EDGE CASE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_edge_extremely_long_lines() {
        let plugin = CPlugin::new();
        let long_line = edge_cases::extremely_long_line();
        let source = format!("int main() {{\n    {}\n    return 0;\n}}\n", long_line);

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&source).await });

        assert!(result.is_ok(), "Should handle extremely long lines");
    }

    #[test]
    fn test_edge_special_regex_chars() {
        let plugin = CPlugin::new();
        let source = format!(
            r#"#include <stdio.h>
int main() {{
    char *pattern = "{}";
    return 0;
}}
"#,
            edge_cases::special_regex_chars()
        );

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&source).await });

        assert!(
            result.is_ok(),
            "Should handle special regex characters in strings"
        );
    }

    // ========================================================================
    // PERFORMANCE TEST (1 test)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_c_file() {
        let plugin = CPlugin::new();

        // Create a large C file with 5000 functions
        let mut large_source = String::from("#include <stdio.h>\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!("int func{}(int x) {{ return x + {}; }}\n", i, i));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let parsed = result.unwrap();
        assert_eq!(parsed.symbols.len(), 5000, "Should find all 5000 functions");
        assert_performance(duration, 5);
    }

    // ========================================================================
    // INTEGRATION TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_integration_parse_and_list_functions() {
        let plugin = CPlugin::new();
        let source = r#"
int square(int x) {
    return x * x;
}

int cube(int x) {
    return x * x * x;
}

int main() {
    return 0;
}
"#;

        // Test parse
        let parse_result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });
        assert!(parse_result.is_ok());
        let parsed = parse_result.unwrap();
        assert!(
            parsed.symbols.len() >= 3,
            "Should find at least 3 functions"
        );

        // Test list_functions
        let list_result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.list_functions(source).await });
        assert!(list_result.is_ok());
        let functions = list_result.unwrap();
        assert!(functions.contains(&"square".to_string()));
        assert!(functions.contains(&"main".to_string()));
    }

    #[test]
    fn test_integration_import_analysis() {
        let plugin = CPlugin::new();
        let source = r#"
#include <stdio.h>
#include <stdlib.h>
#include "utils.h"
#include "config.h"

int main() {
    printf("Hello\n");
    return 0;
}
"#;

        let parse_result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(source).await });
        assert!(parse_result.is_ok());

        // Test import analysis
        let import_result = plugin.analyze_detailed_imports(source, None);
        assert!(import_result.is_ok(), "Should analyze imports");
        let graph = import_result.unwrap();

        // Should have 4 includes
        assert_eq!(graph.imports.len(), 4, "Should find all 4 includes");
    }
}
