//! C language plugin for TypeMill
//!
//! Provides comprehensive C language support including:
//! - AST parsing using tree-sitter
//! - Import/include management (#include directives)
//! - Refactoring operations (extract function/variable, inline variable)
//! - Workspace operations (Makefile-based projects)
//! - CMake and Makefile manifest analysis
//!
//! This plugin supports C99 and C11 standards with `clangd` as the LSP server.

mod ast_parser;
mod cmake_parser;
pub mod constants;
mod import_support;
mod makefile_parser;
mod lsp_installer;
mod project_factory;
mod refactoring;
mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater,
    ModuleReference, ModuleReferenceScanner, ParsedSource, PluginResult,
    ReferenceKind, ScanScope,
};
use std::path::Path;

use mill_foundation::protocol::{ImportGraph, ImportInfo, ImportType};

use crate::constants::{assertion_patterns, test_patterns, INCLUDE_PATTERN, LIBS_PATTERN};

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: CPlugin,
    name: "c",
    extensions: ["c", "h"],
    manifest: "Makefile",
    lsp_command: "clangd",
    lsp_args: [""],
    source_dir: "src",
    entry_point: "main.c",
    module_separator: "::",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::CImportSupport,
        project_factory: project_factory::CProjectFactory,
        workspace_support: workspace_support::CWorkspaceSupport,
        lsp_installer: lsp_installer::CLspInstaller,
    },
    doc: "C language plugin implementation providing comprehensive C language support"
}

#[async_trait]
impl LanguagePlugin for CPlugin {
    impl_language_plugin_basics!();

    /// Parse C source code into an AST representation
    ///
    /// Uses tree-sitter to parse C source and extract symbols (functions, structs, etc.)
    ///
    /// # Arguments
    ///
    /// * `source` - The C source code to parse
    ///
    /// # Returns
    ///
    /// A `ParsedSource` containing extracted symbols with location information
    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        Ok(ast_parser::parse_source(source))
    }

    /// List all function names in C source code
    ///
    /// Extracts function declarations and definitions using tree-sitter AST traversal
    ///
    /// # Arguments
    ///
    /// * `source` - The C source code to analyze
    ///
    /// # Returns
    ///
    /// A vector of function names found in the source
    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        Ok(ast_parser::list_functions(source))
    }

    /// Analyze C project manifest files (Makefile or CMakeLists.txt)
    ///
    /// Parses either CMake or Make-based build configurations to extract
    /// dependencies, targets, and project structure
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the manifest file (Makefile or CMakeLists.txt)
    ///
    /// # Returns
    ///
    /// Structured manifest data containing dependencies and configuration
    ///
    /// # Errors
    ///
    /// Returns an error if the file type is not supported
    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        let filename = path.file_name().and_then(|s| s.to_str()).unwrap_or_default();
        if filename.starts_with("CMakeLists") {
            cmake_parser::analyze_cmake_manifest(path)
        } else if filename == "Makefile" {
            makefile_parser::analyze_makefile_manifest(path)
        } else {
            Err(mill_plugin_api::PluginError::not_supported(
                "Manifest analysis for this file type",
            ))
        }
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl ManifestUpdater for CPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        _old_name: &str,
        new_name: &str,
        _new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = std::fs::read_to_string(manifest_path).unwrap();
        if let Some(caps) = LIBS_PATTERN.captures(&content) {
            let existing_libs = caps.get(1).unwrap().as_str();
            let new_libs = format!("{} -l{}", existing_libs, new_name);
            Ok(content.replace(existing_libs, &new_libs))
        } else {
            Ok(format!("{}\nLIBS = -l{}", content, new_name))
        }
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        let libs = dependencies
            .iter()
            .map(|d| format!("-l{}", d))
            .collect::<Vec<String>>()
            .join(" ");

        format!(
            "CC = gcc\nCFLAGS = -Wall -Wextra -std=c11\nTARGET = {}\nSRCS = src/main.c\nLIBS = {}\n\nall: $(TARGET)\n\n$(TARGET): $(SRCS)\n\t$(CC) $(CFLAGS) -o $(TARGET) $(SRCS) $(LIBS)\n\nclean:\n\trm -f $(TARGET)\n",
            package_name, libs
        )
    }
}

impl ImportAnalyzer for CPlugin {
    fn build_import_graph(&self, file_path: &Path) -> PluginResult<ImportGraph> {
        let content = std::fs::read_to_string(file_path).unwrap();
        let mut imports = Vec::new();

        for (i, line) in content.lines().enumerate() {
            for cap in INCLUDE_PATTERN.captures_iter(line) {
                imports.push(ImportInfo {
                    module_path: cap.get(2).unwrap().as_str().to_string(),
                    import_type: ImportType::CInclude,
                    named_imports: vec![],
                    default_import: None,
                    namespace_import: None,
                    type_only: false,
                    location: mill_foundation::protocol::SourceLocation {
                        start_line: i as u32,
                        start_column: cap.get(2).unwrap().start() as u32,
                        end_line: i as u32,
                        end_column: cap.get(2).unwrap().end() as u32,
                    },
                });
            }
        }

        use chrono::Utc;
        Ok(ImportGraph {
            source_file: file_path.to_str().unwrap().to_string(),
            imports,
            importers: vec![],
            metadata: mill_foundation::protocol::ImportGraphMetadata {
                language: "c".to_string(),
                parsed_at: Utc::now(),
                parser_version: "0.1.0".to_string(),
                circular_dependencies: vec![],
                external_dependencies: vec![],
            },
        })
    }
}

impl ModuleReferenceScanner for CPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: ScanScope,
    ) -> PluginResult<Vec<ModuleReference>> {
        let mut references = Vec::new();

        for (i, line) in content.lines().enumerate() {
            if scope == ScanScope::AllUseStatements && (line.trim().starts_with("//") || line.trim().starts_with("/*")) {
                continue;
            }

            for cap in INCLUDE_PATTERN.captures_iter(line) {
                let header_name = cap.get(2).unwrap().as_str();

                // Filter by module_name if provided
                if module_name.is_empty() || header_name.contains(module_name) {
                    references.push(ModuleReference {
                        text: header_name.to_string(),
                        line: i + 1,
                        column: cap.get(2).unwrap().start(),
                        length: header_name.len(),
                        kind: ReferenceKind::Declaration,
                    });
                }
            }
        }

        Ok(references)
    }
}

// Implement RefactoringProvider trait for CPlugin
#[async_trait]
impl mill_plugin_api::RefactoringProvider for CPlugin {
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
    }

    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_function(source, start_line, end_line, function_name, file_path)
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
    }
}

impl mill_plugin_api::AnalysisMetadata for CPlugin {
    fn test_patterns(&self) -> Vec<regex::Regex> {
        test_patterns()
    }

    fn assertion_patterns(&self) -> Vec<regex::Regex> {
        assertion_patterns()
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::JavaDoc
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec!["static", "extern"]
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["struct", "enum", "typedef"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec!["if", "else", "switch", "case", "for", "while", "do", "&&", "||"]
    }

    fn nesting_penalty(&self) -> f32 {
        1.3
    }
}

#[cfg(test)]
mod tests;