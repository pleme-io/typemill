//! TypeScript/JavaScript Language Plugin for TypeMill
//!
//! Provides comprehensive TypeScript and JavaScript language support including:
//! - AST parsing using tree-sitter (TypeScript, TSX, JavaScript, JSX)
//! - Import management (ES6 imports, CommonJS require, dynamic imports)
//! - Refactoring operations (extract function/variable, inline variable)
//! - Workspace operations (npm, yarn, pnpm package managers)
//! - package.json and tsconfig.json manifest analysis
//! - Path alias resolution (@alias/path support)
//!
//! This plugin supports TypeScript and JavaScript with typescript-language-server as the LSP server.
mod constants;
pub mod import_support;
pub mod imports;
pub mod lsp_installer;
mod manifest;
pub mod parser;
mod path_alias_resolver;
mod project_factory;
pub mod refactoring;
mod regex_patterns; // Re-exports from constants for backward compatibility
mod string_literal_support;
mod tsconfig;
pub mod workspace_support;

use async_trait::async_trait;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics, read_manifest,
};
use mill_plugin_api::{LanguagePlugin, ManifestData, ParsedSource, PluginApiError, PluginResult};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: TypeScriptPlugin,
    name: "typescript",
    extensions: ["ts", "tsx", "js", "jsx", "mjs", "cjs"],
    manifest: "package.json",
    lsp_command: "typescript-language-server",
    lsp_args: ["typescript-language-server", "--stdio"],
    source_dir: "src",
    entry_point: "index.ts",
    module_separator: ".",
    capabilities: [with_imports, with_workspace, with_project_factory],
    fields: {
        import_support: import_support::TypeScriptImportSupport,
        workspace_support: workspace_support::TypeScriptWorkspaceSupport,
        project_factory: project_factory::TypeScriptProjectFactory,
        lsp_installer: lsp_installer::TypeScriptLspInstaller,
        path_alias_resolver: path_alias_resolver::TypeScriptPathAliasResolver,
    },
    doc: "TypeScript/JavaScript language plugin implementation"
}

#[async_trait]
impl LanguagePlugin for TypeScriptPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        let symbols = parser::extract_symbols(source)?;
        Ok(ParsedSource {
            data: serde_json::json!(
                { "language" : "typescript", "symbols_count" : symbols.len() }
            ),
            symbols,
        })
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::load_package_json(path).await
    }

    fn analyze_detailed_imports(
        &self,
        source: &str,
        file_path: Option<&Path>,
    ) -> PluginResult<mill_foundation::protocol::ImportGraph> {
        parser::analyze_imports(source, file_path)
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            module_reference_scanner: ModuleReferenceScanner,
            refactoring_provider: RefactoringProvider,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        },
        path_alias_resolver => {
            path_alias_resolver: PathAliasResolver,
        },
    }

    fn rewrite_file_references(
        &self,
        content: &str,
        old_path: &Path,
        new_path: &Path,
        current_file: &Path,
        project_root: &Path,
        rename_info: Option<&serde_json::Value>,
    ) -> Option<(String, usize)> {
        // First, rewrite imports
        let (content_after_imports, import_count) = self
            .rewrite_imports_for_rename(
                content,
                old_path,
                new_path,
                current_file,
                project_root,
                rename_info,
            )
            .ok()?;

        // Then, rewrite string literals (path-like strings)
        let (final_content, literal_count) = string_literal_support::rewrite_string_literals(
            &content_after_imports,
            old_path,
            new_path,
        )
        .ok()?;

        let total_changes = import_count + literal_count;

        if total_changes > 0 {
            Some((final_content, total_changes))
        } else {
            None
        }
    }
}

// ============================================================================
// Capability Trait Implementations
// ============================================================================

impl mill_plugin_api::ModuleReferenceScanner for TypeScriptPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> mill_plugin_api::PluginResult<Vec<mill_plugin_api::ModuleReference>> {
        Ok(self.find_module_references(content, module_name, scope))
    }
}

#[async_trait]
impl mill_plugin_api::RefactoringProvider for TypeScriptPlugin {
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        variable_line: u32,
        variable_col: u32,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_inline_variable(source, variable_line, variable_col, file_path)
    }

    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        function_name: &str,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_function(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            function_name,
            file_path,
        )
    }

    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
    }

    fn supports_extract_constant(&self) -> bool {
        true
    }

    async fn plan_extract_constant(
        &self,
        source: &str,
        line: u32,
        character: u32,
        constant_name: &str,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_extract_constant(source, line, character, constant_name, file_path)
    }

    fn supports_symbol_move(&self) -> bool {
        true
    }

    async fn plan_symbol_move(
        &self,
        source: &str,
        symbol_line: u32,
        symbol_col: u32,
        file_path: &str,
        destination: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_symbol_move(source, symbol_line, symbol_col, file_path, destination)
    }

    fn supports_symbol_delete(&self) -> bool {
        true
    }

    async fn plan_symbol_delete(
        &self,
        source: &str,
        symbol_line: u32,
        symbol_col: u32,
        file_path: &str,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::EditPlan> {
        refactoring::plan_symbol_delete(source, symbol_line, symbol_col, file_path)
    }
}

impl mill_plugin_api::ImportAnalyzer for TypeScriptPlugin {
    fn build_import_graph(
        &self,
        file_path: &Path,
    ) -> mill_plugin_api::PluginResult<mill_foundation::protocol::ImportGraph> {
        // Read the file content
        let content = std::fs::read_to_string(file_path).map_err(|e| {
            mill_plugin_api::PluginApiError::internal(format!("Failed to read file: {}", e))
        })?;

        // Use the existing analyze_detailed_imports method
        self.analyze_detailed_imports(&content, Some(file_path))
    }
}

// ============================================================================
// Manifest Updater Capability
// ============================================================================

#[async_trait::async_trait]
impl mill_plugin_api::ManifestUpdater for TypeScriptPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> mill_plugin_api::PluginResult<String> {
        // Delegate to the inherent method implementation
        TypeScriptPlugin::update_dependency(self, manifest_path, old_name, new_name, new_version)
            .await
    }

    fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        // Delegate to the inherent method implementation
        TypeScriptPlugin::generate_manifest(self, package_name, dependencies)
    }
}

// ============================================================================
// Plugin-specific helper methods
// ============================================================================

impl TypeScriptPlugin {
    pub async fn update_dependency(
        &self,
        manifest_path: &Path,
        _old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = read_manifest(manifest_path).await?;
        let version = new_version.ok_or_else(|| {
            PluginApiError::invalid_input("Version required for package.json dependency updates")
        })?;
        manifest::update_dependency(&content, new_name, version)
    }

    /// Generates a new package.json manifest file with the given name and dependencies.
    ///
    /// Creates a basic package.json with the specified package name and dependency list.
    ///
    /// # Arguments
    /// * `package_name` - The name field for package.json
    /// * `dependencies` - List of npm package names to include as dependencies
    ///
    /// # Returns
    /// Complete package.json content as a JSON string
    pub fn generate_manifest(&self, package_name: &str, dependencies: &[String]) -> String {
        manifest::generate_manifest(package_name, dependencies)
    }

    /// Find module references (supports both import statements and qualified paths)
    pub fn find_module_references(
        &self,
        content: &str,
        module_to_find: &str,
        scope: mill_plugin_api::ScanScope,
    ) -> Vec<mill_plugin_api::ModuleReference> {
        use mill_plugin_api::{ModuleReference, ReferenceKind, ScanScope};
        let mut references = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_idx = line_num + 1;

            // Find import statements: "import ... from 'module'" or "import module"
            if scope != ScanScope::QualifiedPaths
                && (line.contains("import") || line.contains("from"))
                && line.contains(module_to_find)
            {
                references.push(ModuleReference {
                    line: line_idx,
                    column: 0,
                    length: line.len(),
                    text: line.to_string(),
                    kind: ReferenceKind::Declaration,
                });
            }

            // Find qualified paths: "module.function()"
            if scope == ScanScope::QualifiedPaths || scope == ScanScope::All {
                let pattern = format!("{}.", module_to_find);
                for (idx, _) in line.match_indices(&pattern) {
                    // Skip if this is inside a string (simple heuristic)
                    let before = &line[..idx];
                    let in_single_quote = before.matches('\'').count() % 2 == 1;
                    let in_double_quote = before.matches('"').count() % 2 == 1;
                    let in_template = before.matches('`').count() % 2 == 1;

                    if !in_single_quote && !in_double_quote && !in_template {
                        references.push(ModuleReference {
                            line: line_idx,
                            column: idx,
                            length: module_to_find.len(),
                            text: module_to_find.to_string(),
                            kind: ReferenceKind::QualifiedPath,
                        });
                    }
                }
            }
        }

        references
    }

    /// Rewrite imports for rename (minimal implementation for compatibility)
    pub fn rewrite_imports_for_rename(
        &self,
        content: &str,
        old_path: &Path,
        new_path: &Path,
        importing_file: &Path,
        project_root: &Path,
        _rename_info: Option<&serde_json::Value>,
    ) -> PluginResult<(String, usize)> {
        // Use the standalone function with full context and path alias resolver
        Ok(import_support::rewrite_imports_for_move_with_context(
            content,
            old_path,
            new_path,
            importing_file,
            Some(&self.path_alias_resolver),
            Some(project_root),
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{LanguagePlugin, ScanScope};

    #[test]
    fn test_typescript_capabilities() {
        let plugin = TypeScriptPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();
        let caps = plugin_trait.capabilities();
        assert!(caps.imports, "TypeScript plugin should support imports");
        assert!(caps.workspace, "TypeScript plugin should support workspace");
    }

    #[test]
    fn test_typescript_workspace_support() {
        let plugin = TypeScriptPlugin::new();
        let plugin_trait: &dyn LanguagePlugin = plugin.as_ref();
        assert!(
            plugin_trait.workspace_support().is_some(),
            "TypeScript should have workspace support"
        );
    }

    // ========================================================================
    // EDGE CASE TESTS (8 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_edge_parse_unicode_identifiers() {
        let plugin = TypeScriptPlugin::new();
        let source = r#"
import { readFile } from 'fs';
function тестфункция() {
    const مُتَغَيِّر = 42;
}
"#;
        let result = plugin.parse(source).await;
        // Should not panic with Unicode identifiers
        assert!(
            result.is_ok(),
            "Should parse Unicode identifiers successfully: {:?}",
            result.err()
        );
    }

    #[tokio::test]
    async fn test_edge_parse_extremely_long_line() {
        let plugin = TypeScriptPlugin::new();
        let long_string = "a".repeat(15000);
        let source = format!("const x = \"{}\";\n", long_string);
        let result = plugin.parse(&source).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_edge_parse_no_newlines() {
        let plugin = TypeScriptPlugin::new();
        let source = "function main() { console.log('hello'); }";
        let result = plugin.parse(source).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_edge_scan_mixed_line_endings() {
        let plugin = TypeScriptPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");
        let content =
            "import { readFile } from 'fs';\r\nimport path from 'path';\nimport os from 'os';";
        let refs = scanner
            .scan_references(content, "fs", ScanScope::All)
            .expect("Should scan");
        assert_eq!(refs.len(), 1);
    }

    #[tokio::test]
    async fn test_edge_parse_empty_file() {
        let plugin = TypeScriptPlugin::new();
        let result = plugin.parse("").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[tokio::test]
    async fn test_edge_parse_whitespace_only() {
        let plugin = TypeScriptPlugin::new();
        let result = plugin.parse("   \n\n\t\t\n   ").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().symbols.len(), 0);
    }

    #[test]
    fn test_edge_scan_special_regex_chars() {
        let plugin = TypeScriptPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");
        let content = "import { readFile } from 'fs';";
        // Test with special regex characters
        let result = scanner.scan_references(content, "f.*", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    #[test]
    fn test_edge_handle_null_bytes() {
        let plugin = TypeScriptPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");
        let content = "import { readFile } from 'fs';\x00\nimport path from 'path';";
        let result = scanner.scan_references(content, "fs", ScanScope::All);
        assert!(result.is_ok()); // Should not panic
    }

    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = TypeScriptPlugin::new();

        // Create a large TypeScript file (~100KB, 5000 functions)
        let mut large_source = String::from("import { readFile } from 'fs';\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!(
                "function function{}(): number {{ return {}; }}\n",
                i, i
            ));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        let symbols = result.unwrap().symbols;
        assert_eq!(symbols.len(), 5000, "Should find all 5000 functions");
        assert!(
            duration.as_secs() < 5,
            "Should parse within 5 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = TypeScriptPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("import { readFile } from 'fs';\n\n");
        for _ in 0..10000 {
            content.push_str("fs.readFileSync('test.txt');\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "fs", ScanScope::All)
            .expect("Should scan");
        let duration = start.elapsed();

        assert_eq!(
            refs.len(),
            10001,
            "Should find import + 10K qualified paths"
        );
        assert!(
            duration.as_secs() < 10,
            "Should scan within 10 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // INTEGRATION TESTS (2 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_integration_package_and_imports() {
        let harness = mill_test_support::harness::IntegrationTestHarness::new()
            .expect("Should create harness");

        // Create package.json
        harness
            .create_source_file(
                "package.json",
                r#"{"name": "test-app", "dependencies": {"lodash": "^4.17.21"}}"#,
            )
            .expect("Should create package.json");

        // Create TypeScript file with imports
        let source = r#"
import { readFile } from 'fs';
import { map } from 'lodash';

export function process(data: string[]): number[] {
    return map(data, (item) => item.length);
}
"#;
        harness
            .create_source_file("index.ts", source)
            .expect("Should create index.ts");

        // Verify structure
        let package_content = harness
            .read_file("package.json")
            .expect("Should read package.json");
        assert!(package_content.contains("name"));
        assert!(package_content.contains("dependencies"));

        let ts_content = harness.read_file("index.ts").expect("Should read index.ts");
        assert!(ts_content.contains("import"));
        assert!(ts_content.contains("from"));
    }

    #[tokio::test]
    async fn test_integration_module_refactoring() {
        let harness = mill_test_support::harness::IntegrationTestHarness::new()
            .expect("Should create harness");

        // Create source with exports
        harness
            .create_source_file("utils.ts", "export function helper() { return 42; }")
            .expect("Should create utils.ts");

        harness
            .create_source_file("main.ts", "import { helper } from './utils';\n\nhelper();")
            .expect("Should create main.ts");

        // Parse and verify
        let plugin = TypeScriptPlugin::new();

        let utils_content = harness.read_file("utils.ts").expect("Should read utils.ts");
        let parsed = plugin.parse(&utils_content).await.expect("Should parse");
        assert!(!parsed.symbols.is_empty());

        assert!(utils_content.contains("export"));
        assert!(utils_content.contains("function"));

        let main_content = harness.read_file("main.ts").expect("Should read main.ts");
        assert!(main_content.contains("import"));
        assert!(main_content.contains("./utils"));
    }
}
