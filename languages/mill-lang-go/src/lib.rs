//! Go Language Plugin for TypeMill
//!
//! This crate provides complete Go language support, implementing the
//! `LanguagePlugin` trait from `mill_plugin_api`.

mod constants;
pub mod import_support;
pub mod lsp_installer;
mod manifest;
pub mod parser;
pub mod project_factory;
pub mod refactoring;
pub mod workspace_support;

use async_trait::async_trait;
use mill_foundation::protocol::EditPlan;
use mill_foundation::protocol::ImportGraph;
use mill_lang_common::{
    define_language_plugin, impl_capability_delegations, impl_language_plugin_basics,
};
use mill_plugin_api::{
    ImportAnalyzer, LanguagePlugin, ManifestData, ManifestUpdater, ModuleReference,
    ModuleReferenceScanner, ParsedSource, PluginApiError, PluginResult, RefactoringProvider,
    ReferenceKind, ScanScope,
};
use std::path::Path;

// Define the plugin with all scaffolding generated by macro
define_language_plugin! {
    struct: GoPlugin,
    name: "go",
    extensions: ["go"],
    manifest: "go.mod",
    lsp_command: "gopls",
    lsp_args: [""],
    source_dir: ".",
    entry_point: "main.go",
    module_separator: "/",
    capabilities: [with_imports, with_project_factory, with_workspace],
    fields: {
        import_support: import_support::GoImportSupport,
        project_factory: project_factory::GoProjectFactory,
        workspace_support: workspace_support::GoWorkspaceSupport,
        lsp_installer: lsp_installer::GoLspInstaller,
    },
    doc: "Go language plugin implementation providing comprehensive Go language support"
}

#[async_trait]
impl LanguagePlugin for GoPlugin {
    impl_language_plugin_basics!();

    async fn parse(&self, source: &str) -> PluginResult<ParsedSource> {
        let symbols = parser::extract_symbols(source)?;

        Ok(ParsedSource {
            data: serde_json::json!({
                "language": "go",
                "symbols_count": symbols.len()
            }),
            symbols,
        })
    }

    async fn analyze_manifest(&self, path: &Path) -> PluginResult<ManifestData> {
        manifest::load_go_mod(path).await
    }

    async fn list_functions(&self, source: &str) -> PluginResult<Vec<String>> {
        parser::list_functions(source)
    }

    // Use macro to generate capability delegation methods
    impl_capability_delegations! {
        this => {
            refactoring_provider: RefactoringProvider,
            module_reference_scanner: ModuleReferenceScanner,
            import_analyzer: ImportAnalyzer,
            manifest_updater: ManifestUpdater,
        },
        import_support => {
            import_parser: ImportParser,
            import_rename_support: ImportRenameSupport,
            import_move_support: ImportMoveSupport,
            import_mutation_support: ImportMutationSupport,
            import_advanced_support: ImportAdvancedSupport,
        },
        project_factory => {
            project_factory: ProjectFactory,
        },
        workspace_support => {
            workspace_support: WorkspaceSupport,
        },
        lsp_installer => {
            lsp_installer: LspInstaller,
        }
    }
}

#[async_trait]
impl ManifestUpdater for GoPlugin {
    async fn update_dependency(
        &self,
        manifest_path: &Path,
        old_name: &str,
        new_name: &str,
        new_version: Option<&str>,
    ) -> PluginResult<String> {
        let content = tokio::fs::read_to_string(manifest_path)
            .await
            .map_err(|e| PluginApiError::internal(e.to_string()))?;
        manifest::update_dependency(&content, old_name, new_name, new_version)
    }

    fn generate_manifest(&self, package_name: &str, _dependencies: &[String]) -> String {
        manifest::generate_manifest(package_name, constants::DEFAULT_GO_VERSION)
    }
}

impl ImportAnalyzer for GoPlugin {
    fn build_import_graph(&self, file_path: &Path) -> PluginResult<ImportGraph> {
        let content = std::fs::read_to_string(file_path)
            .map_err(|e| PluginApiError::internal(e.to_string()))?;
        parser::analyze_imports(&content, Some(file_path))
    }
}

impl ModuleReferenceScanner for GoPlugin {
    fn scan_references(
        &self,
        content: &str,
        module_name: &str,
        scope: ScanScope,
    ) -> PluginResult<Vec<ModuleReference>> {
        let mut references = Vec::new();
        let import_pattern = (constants::MODULE_IN_IMPORT_PATTERN)(module_name);
        let import_re = regex::Regex::new(&import_pattern)
            .map_err(|e| PluginApiError::internal(format!("Invalid regex: {}", e)))?;

        // Compile qualified path regex once outside the loop for performance
        let qualified_re = if scope == ScanScope::All || scope == ScanScope::QualifiedPaths {
            let qualified_pattern = (constants::QUALIFIED_PATH_PATTERN)(module_name);
            Some(
                regex::Regex::new(&qualified_pattern)
                    .map_err(|e| PluginApiError::internal(format!("Invalid regex: {}", e)))?,
            )
        } else {
            None
        };

        for (i, line) in content.lines().enumerate() {
            let line_num = i + 1; // Convert to 1-indexed line numbering

            // Only scan lines that look like imports (context-aware)
            // This avoids false positives in string literals or comments
            let trimmed = line.trim();
            if trimmed.starts_with("import") || (trimmed.starts_with('"') && i > 0) {
                for mat in import_re.find_iter(line) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: mat.len(),
                        text: mat.as_str().to_string(),
                        kind: ReferenceKind::Declaration,
                    });
                }
            }

            // Scan for qualified paths like `fmt.Println`
            if let Some(ref qualified_re) = qualified_re {
                // Skip lines that are comments
                if trimmed.starts_with("//") || trimmed.starts_with("/*") {
                    continue;
                }

                // Strip inline comments before matching
                let code_only = line.split("//").next().unwrap_or(line);

                for mat in qualified_re.find_iter(code_only) {
                    references.push(ModuleReference {
                        line: line_num,
                        column: mat.start(),
                        length: mat.len(),
                        text: mat.as_str().to_string(),
                        kind: ReferenceKind::QualifiedPath,
                    });
                }
            }
        }

        Ok(references)
    }
}

#[async_trait]
impl RefactoringProvider for GoPlugin {
    // extract_function
    fn supports_extract_function(&self) -> bool {
        true
    }

    async fn plan_extract_function(
        &self,
        source: &str,
        start_line: u32,
        end_line: u32,
        function_name: &str,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_extract_function(source, start_line, end_line, function_name, file_path)
    }

    // inline_variable
    fn supports_inline_variable(&self) -> bool {
        true
    }

    async fn plan_inline_variable(
        &self,
        source: &str,
        line: u32,
        col: u32,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_inline_variable(source, line, col, file_path)
    }

    // extract_variable
    fn supports_extract_variable(&self) -> bool {
        true
    }

    async fn plan_extract_variable(
        &self,
        source: &str,
        start_line: u32,
        start_col: u32,
        end_line: u32,
        end_col: u32,
        variable_name: Option<String>,
        file_path: &str,
    ) -> PluginResult<EditPlan> {
        refactoring::plan_extract_variable(
            source,
            start_line,
            start_col,
            end_line,
            end_col,
            variable_name,
            file_path,
        )
    }
}

impl mill_plugin_api::AnalysisMetadata for GoPlugin {
    fn test_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"func\s+Test").unwrap(),
            regex::Regex::new(r"func\s+Benchmark").unwrap(),
            regex::Regex::new(r"func\s+Example").unwrap(),
        ]
    }

    fn assertion_patterns(&self) -> Vec<regex::Regex> {
        vec![
            regex::Regex::new(r"t\.Error").unwrap(),
            regex::Regex::new(r"t\.Fail").unwrap(),
            regex::Regex::new(r"assert\.").unwrap(),
            regex::Regex::new(r"require\.").unwrap(),
        ]
    }

    fn doc_comment_style(&self) -> mill_plugin_api::DocCommentStyle {
        mill_plugin_api::DocCommentStyle::GoDoc
    }

    fn visibility_keywords(&self) -> Vec<&'static str> {
        vec![] // Go uses capitalization, not keywords
    }

    fn interface_keywords(&self) -> Vec<&'static str> {
        vec!["interface", "struct", "type"]
    }

    fn complexity_keywords(&self) -> Vec<&'static str> {
        vec!["if", "for", "switch", "case", "select", "&&", "||"]
    }

    fn nesting_penalty(&self) -> f32 {
        1.2
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mill_plugin_api::{
        CreatePackageConfig, LanguagePlugin, LspInstaller, ScanScope, Template, WorkspaceSupport,
    };
    use tempfile::tempdir;

    #[test]
    fn test_go_metadata() {
        let plugin = GoPlugin::default();
        let metadata = plugin.metadata();
        assert_eq!(metadata.name, "go");
    }

    #[test]
    fn test_go_capabilities() {
        let plugin = GoPlugin::default();
        let caps = plugin.capabilities();
        assert!(caps.imports);
        assert!(caps.workspace);
    }

    #[test]
    fn test_create_package() {
        let plugin = GoPlugin::default();
        let factory = plugin.project_factory().unwrap();
        let tmp_dir = tempdir().unwrap();
        let config = CreatePackageConfig {
            package_path: "my-go-app".to_string(),
            workspace_root: tmp_dir.path().to_str().unwrap().to_string(),
            add_to_workspace: false,
            package_type: mill_plugin_api::PackageType::Binary,
            template: Template::Minimal,
        };

        let result = factory.create_package(&config).unwrap();
        assert_eq!(result.created_files.len(), 2);
        assert!(result.created_files[0].contains("go.mod"));
        assert!(result.created_files[1].contains("main.go"));

        let go_mod_content =
            std::fs::read_to_string(tmp_dir.path().join("my-go-app/go.mod")).unwrap();
        assert!(go_mod_content.contains("module my-go-app"));
    }

    #[test]
    fn test_import_advanced_support_returns_some() {
        let plugin = GoPlugin::default();
        assert!(plugin.import_advanced_support().is_some());
    }

    #[tokio::test]
    async fn test_refactoring_provider_extract_function() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tprintln(\"hello\")\n}";
        let plan = provider
            .plan_extract_function(source, 3, 3, "greet", "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    #[tokio::test]
    async fn test_refactoring_provider_inline_variable() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tconst x = \"hello\"\n\tprintln(x)\n}";
        let plan = provider
            .plan_inline_variable(source, 3, 8, "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    #[tokio::test]
    async fn test_refactoring_provider_extract_variable() {
        let plugin = GoPlugin::default();
        let provider = plugin.refactoring_provider().unwrap();
        let source = "package main\n\nfunc main() {\n\tprintln(\"hello\")\n}";
        let plan = provider
            .plan_extract_variable(source, 3, 9, 3, 16, Some("greeting".to_string()), "main.go")
            .await
            .unwrap();
        assert_eq!(plan.edits.len(), 2);
    }

    // Workspace tests deleted - covered by workspace_harness integration tests
    // See: crates/mill-test-support/src/harness/workspace_harness.rs

    #[test]
    fn test_module_reference_scanner() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        let refs = scanner
            .scan_references(content, "fmt", ScanScope::All)
            .unwrap();
        assert_eq!(refs.len(), 1);
        assert_eq!(refs[0].line, 3); // Line 3 (1-indexed): import "fmt"
    }

    #[test]
    fn test_import_analyzer() {
        let plugin = GoPlugin::default();
        let analyzer = plugin.import_analyzer().unwrap();
        let tmp_dir = tempdir().unwrap();
        let file_path = tmp_dir.path().join("main.go");
        std::fs::write(&file_path, "package main\n\nimport \"fmt\"").unwrap();
        let graph = analyzer.build_import_graph(&file_path).unwrap();
        assert_eq!(graph.imports.len(), 1);
        assert_eq!(graph.imports[0].module_path, "fmt");
    }

    #[tokio::test]
    async fn test_manifest_updater() {
        let plugin = GoPlugin::default();
        let updater = plugin.manifest_updater().unwrap();
        let tmp_dir = tempdir().unwrap();
        let file_path = tmp_dir.path().join("go.mod");
        std::fs::write(
            &file_path,
            "module my-go-app\n\nrequire example.com/pkg v1.2.3",
        )
        .unwrap();
        let updated = updater
            .update_dependency(
                &file_path,
                "example.com/pkg",
                "example.com/newpkg",
                Some("v1.2.4"),
            )
            .await
            .unwrap();
        assert!(updated.contains("example.com/newpkg v1.2.4"));
    }

    // ========================================================================
    // ERROR PATH TESTS
    // ========================================================================

    #[tokio::test]
    async fn test_parse_invalid_source() {
        let plugin = GoPlugin::default();
        // Malformed Go code should still parse symbols gracefully
        let result = plugin.parse("this is not valid go code {{{").await;
        assert!(
            result.is_ok(),
            "Parser should handle invalid source gracefully"
        );
    }

    #[tokio::test]
    async fn test_analyze_nonexistent_manifest() {
        let plugin = GoPlugin::default();
        let result = plugin
            .analyze_manifest(Path::new("/nonexistent/go.mod"))
            .await;
        assert!(result.is_err(), "Should error on nonexistent manifest");
    }

    #[test]
    fn test_scan_references_with_empty_module_name() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        let result = scanner.scan_references(content, "", ScanScope::All);
        assert!(result.is_ok(), "Should handle empty module name");
    }

    #[test]
    fn test_module_reference_scanner_with_invalid_regex_chars() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"fmt\"";
        // Test with special regex characters (should be escaped)
        let result = scanner.scan_references(content, "fmt.+*", ScanScope::All);
        assert!(result.is_ok(), "Should handle special regex characters");
    }

    // ========================================================================
    // EDGE CASE TESTS
    // ========================================================================

    #[test]
    fn test_scan_references_with_unicode_module_names() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\nimport \"日本語/パッケージ\"\n\n日本語.Function()";
        let refs = scanner
            .scan_references(content, "日本語", ScanScope::All)
            .unwrap();
        // Should find at least the qualified path (even if import detection is limited)
        assert!(
            !refs.is_empty(),
            "Should find Unicode module names in qualified paths"
        );
    }

    #[tokio::test]
    async fn test_parse_extremely_long_line() {
        let plugin = GoPlugin::default();
        // Create a very long line (>10,000 chars)
        let long_string = "a".repeat(15000);
        let source = format!("package main\n\nconst x = \"{}\"\n", long_string);
        let result = plugin.parse(&source).await;
        assert!(result.is_ok(), "Should handle extremely long lines");
    }

    #[tokio::test]
    async fn test_parse_no_newlines() {
        let plugin = GoPlugin::default();
        let source = "package main func main() { fmt.Println(\"Hello\") }";
        let result = plugin.parse(source).await;
        assert!(result.is_ok(), "Should handle source without newlines");
    }

    #[test]
    fn test_scan_references_with_mixed_line_endings() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        // Mix CRLF and LF
        let content = "package main\r\nimport \"fmt\"\nimport \"strings\"";
        let refs = scanner
            .scan_references(content, "fmt", ScanScope::All)
            .unwrap();
        assert_eq!(refs.len(), 1, "Should handle mixed line endings");
    }

    #[test]
    fn test_scan_references_excludes_comments() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "// fmt.Println should not match\n/* fmt.Println */\nfmt.Println(\"real\")";
        let refs = scanner
            .scan_references(content, "fmt", ScanScope::QualifiedPaths)
            .unwrap();
        // Should only find the non-comment reference
        assert_eq!(
            refs.len(),
            1,
            "Should exclude comments from qualified path matching"
        );
    }

    // ========================================================================
    // PERFORMANCE TESTS
    // ========================================================================

    #[test]
    fn test_parse_large_file() {
        use std::time::Instant;
        let plugin = GoPlugin::default();

        // Create a large Go file (~100KB)
        let mut large_source = String::from("package main\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!("func function{}() {{}}\n", i));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        assert!(result.is_ok(), "Should parse large file");
        assert!(
            duration.as_secs() < 5,
            "Should parse large file within 5 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_scan_many_references_performance() {
        use std::time::Instant;
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();

        // Create content with many references
        let mut content = String::from("package main\n\n");
        for _ in 0..10000 {
            content.push_str("fmt.Println(\"test\")\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "fmt", ScanScope::All)
            .unwrap();
        let duration = start.elapsed();

        assert_eq!(refs.len(), 10000, "Should find all references");
        // Relaxed timing for CI environments (10s threshold)
        assert!(
            duration.as_secs() < 10,
            "Should scan 10K references within 10 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // ROBUSTNESS TESTS
    // ========================================================================

    #[tokio::test]
    async fn test_parse_empty_source() {
        let plugin = GoPlugin::default();
        let result = plugin.parse("").await;
        assert!(result.is_ok(), "Should handle empty source");
        assert_eq!(
            result.unwrap().symbols.len(),
            0,
            "Empty source should have no symbols"
        );
    }

    #[tokio::test]
    async fn test_parse_whitespace_only() {
        let plugin = GoPlugin::default();
        let result = plugin.parse("   \n\n\t\t\n   ").await;
        assert!(result.is_ok(), "Should handle whitespace-only source");
    }

    #[test]
    fn test_scan_references_with_null_bytes() {
        let plugin = GoPlugin::default();
        let scanner = plugin.module_reference_scanner().unwrap();
        let content = "package main\n\x00import \"fmt\"\n";
        let result = scanner.scan_references(content, "fmt", ScanScope::All);
        // Should not panic, may or may not find the import
        assert!(result.is_ok(), "Should handle null bytes gracefully");
    }

    #[test]
    fn test_analysis_metadata_test_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = GoPlugin::default();
        let patterns = plugin.test_patterns();

        // Should match Go test functions
        let test_sample = "func TestSomething(t *testing.T) {}";
        assert!(patterns.iter().any(|p| p.is_match(test_sample)));

        // Should match Go benchmark functions
        let bench_sample = "func BenchmarkOperation(b *testing.B) {}";
        assert!(patterns.iter().any(|p| p.is_match(bench_sample)));

        // Should match Go example functions
        let example_sample = "func ExampleFunction() {}";
        assert!(patterns.iter().any(|p| p.is_match(example_sample)));
    }

    #[test]
    fn test_analysis_metadata_assertion_patterns() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = GoPlugin::default();
        let patterns = plugin.assertion_patterns();

        // Should match testing.T.Error
        let error_sample = "t.Error(\"error message\")";
        assert!(patterns.iter().any(|p| p.is_match(error_sample)));

        // Should match testing.T.Fail
        let fail_sample = "t.Fail()";
        assert!(patterns.iter().any(|p| p.is_match(fail_sample)));

        // Should match testify/assert
        let assert_sample = "assert.Equal(t, expected, actual)";
        assert!(patterns.iter().any(|p| p.is_match(assert_sample)));

        // Should match testify/require
        let require_sample = "require.NoError(t, err)";
        assert!(patterns.iter().any(|p| p.is_match(require_sample)));
    }

    #[test]
    fn test_analysis_metadata_complexity_keywords() {
        use mill_plugin_api::AnalysisMetadata;
        let plugin = GoPlugin::default();
        let keywords = plugin.complexity_keywords();

        // Should include Go control flow keywords
        assert!(keywords.contains(&"if"));
        assert!(keywords.contains(&"for"));
        assert!(keywords.contains(&"switch"));
        assert!(keywords.contains(&"case"));
        assert!(keywords.contains(&"select"));
        assert!(keywords.contains(&"&&"));
        assert!(keywords.contains(&"||"));

        // Check nesting penalty
        assert_eq!(plugin.nesting_penalty(), 1.2);
    }

    // ========================================================================
    // Edge case tests moved to mill-test-support/tests/edge_case_harness_integration.rs
    // ========================================================================
    // PERFORMANCE TESTS (2 tests)
    // ========================================================================

    #[test]
    fn test_performance_parse_large_file() {
        use std::time::Instant;
        let plugin = GoPlugin::new();

        // Create a large Go file (~100KB, 5000 functions)
        let mut large_source = String::from("package main\nimport \"fmt\"\n\n");
        for i in 0..5000 {
            large_source.push_str(&format!("func function{}() int {{ return {} }}\n", i, i));
        }

        let start = Instant::now();
        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async { plugin.parse(&large_source).await });
        let duration = start.elapsed();

        // Main goal: verify parsing large files doesn't crash/panic
        assert!(result.is_ok(), "Should parse large file without panic");
        // Performance: should complete in reasonable time even if symbol extraction is incomplete
        assert!(
            duration.as_secs() < 10,
            "Should parse within 10 seconds, took {:?}",
            duration
        );
    }

    #[test]
    fn test_performance_scan_many_references() {
        use std::time::Instant;
        let plugin = GoPlugin::new();
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");

        // Create content with 10,000 references
        let mut content = String::from("import \"fmt\"\n\n");
        for _ in 0..10000 {
            content.push_str("fmt.Println(\"test\")\n");
        }

        let start = Instant::now();
        let refs = scanner
            .scan_references(&content, "fmt", ScanScope::All)
            .expect("Should scan");
        let duration = start.elapsed();

        assert_eq!(
            refs.len(),
            10001,
            "Should find import + 10K qualified paths"
        );
        assert!(
            duration.as_secs() < 10,
            "Should scan within 10 seconds, took {:?}",
            duration
        );
    }

    // ========================================================================
    // INTEGRATION TESTS (3 tests)
    // ========================================================================

    #[tokio::test]
    async fn test_integration_package_creation_workflow() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = GoPlugin::new();

        // 1. Create Go package with go.mod
        let go_mod_content = r#"module example.com/myapp

go 1.21

require (
    github.com/some/package v1.0.0
)
"#;
        harness
            .create_source_file("go.mod", go_mod_content)
            .expect("Failed to create go.mod");

        // 2. Create Go source file with basic structure
        let source = "package main\n\nfunc add(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    x := add(5, 3)\n    println(x)\n}\n";

        harness
            .create_source_file("main.go", source)
            .expect("Failed to create main.go");

        // 3. Verify file structure
        let content = harness
            .read_file("main.go")
            .expect("Failed to read file");
        assert!(content.contains("package main"));
        assert!(content.contains("func add"));
        assert!(content.contains("func main"));

        // 4. Verify package manifest can be analyzed
        let manifest = plugin
            .analyze_manifest(&harness.root().join("go.mod"))
            .await
            .expect("Failed to analyze go.mod");

        assert!(!manifest.dependencies.is_empty(), "Should find dependencies");
    }

    #[tokio::test]
    async fn test_integration_import_analysis() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = GoPlugin::new();

        // 1. Create a simple file with imports
        let source = "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello\")\n}\n";

        harness
            .create_source_file("main.go", source)
            .expect("Failed to create main.go");

        // 2. Test import analysis
        let analyzer = plugin
            .import_analyzer()
            .expect("Should have import analyzer");
        let graph = analyzer
            .build_import_graph(&harness.root().join("main.go"))
            .expect("Failed to build import graph");

        // Verify imports detected
        assert!(graph.imports.len() >= 2, "Should find fmt and os imports");

        // 3. Verify module reference scanner works
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");
        let refs = scanner
            .scan_references(source, "fmt", ScanScope::All)
            .expect("Should scan references");
        assert!(!refs.is_empty(), "Should find fmt references");
    }

    #[tokio::test]
    async fn test_integration_refactor_roundtrip() {
        use mill_test_support::harness::IntegrationTestHarness;

        let harness = IntegrationTestHarness::new().expect("Failed to create harness");
        let plugin = GoPlugin::new();

        // 1. Create source file with cleaner syntax
        let source = r#"package main

import "fmt"

func add(a, b int) int {
	return a + b
}

func main() {
	x := add(10, 5)
	fmt.Println(x)
}
"#;

        harness
            .create_source_file("math.go", source)
            .expect("Failed to create math.go");

        // 2. Parse to verify valid structure
        let parsed = plugin
            .parse(source)
            .await
            .expect("Failed to parse");

        // Verify parsing works (symbols may be empty or partial based on parser)
        let _symbols = parsed.symbols;

        // 3. Verify file integrity
        let content = harness
            .read_file("math.go")
            .expect("Failed to read file");
        assert!(content.contains("package main"), "Should preserve package");
        assert!(content.contains("func main"), "Should preserve main function");
        assert!(content.contains("import \"fmt\""), "Should preserve imports");

        // 4. Verify we can work with the file content
        let scanner = plugin
            .module_reference_scanner()
            .expect("Should have scanner");
        let refs = scanner
            .scan_references(&content, "fmt", ScanScope::All)
            .expect("Should scan");
        assert!(!refs.is_empty(), "Should find fmt references");
    }
}
